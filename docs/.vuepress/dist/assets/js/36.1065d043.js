(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{536:function(t,e,a){"use strict";a.r(e);var s=a(6),i=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("Java 集合类、接口、抽象类介绍\n")]),t._v(" "),a("h2",{attrs:{id:"interface-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interface-接口"}},[t._v("#")]),t._v(" interface(接口)")]),t._v(" "),a("h3",{attrs:{id:"接口定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口定义"}},[t._v("#")]),t._v(" 接口定义")]),t._v(" "),a("p",[t._v("接口就是一个规范和抽象类比较相似。它只管做什么,不管怎么做。通俗的讲,接口就是某个事物对外提供的一\n些功能的声明,其定义和类比较相似,只不过是通过interface关键字来完成")]),t._v(" "),a("h3",{attrs:{id:"知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#知识点"}},[t._v("#")]),t._v(" 知识点")]),t._v(" "),a("ul",[a("li",[t._v("接口中的所有属性默认为: public static final *** (属性不能够被更改) ;")]),t._v(" "),a("li",[t._v("接口中的所有方法默认为: public abstract **** (方法默认为抽象方法,实现类必须去重写接口中的方法) ;")]),t._v(" "),a("li",[t._v("接口不再像类-样用关键字extends去“继承”, 而是用implements去“实现”, 也就是说类和接口的关系\n叫做实现")])]),t._v(" "),a("h3",{attrs:{id:"接口实现的注意点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口实现的注意点"}},[t._v("#")]),t._v(" 接口实现的注意点")]),t._v(" "),a("ul",[a("li",[t._v("实现一个接口就是要实现该接口的所有的方法(抽象类除外)。")]),t._v(" "),a("li",[t._v("接口中的方法都是抽象的。")]),t._v(" "),a("li",[t._v("多个无关的类可以实现同一个接口, 一个类可以实现多个无关的接口。")])]),t._v(" "),a("h3",{attrs:{id:"extends与implements的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extends与implements的区别"}},[t._v("#")]),t._v(" extends与implements的区别")]),t._v(" "),a("p",[t._v("extends 是继承父类, 只要那个类不是声明为final或者那个类定义为abstract的就能继承, JAVA中不支持多重继承, 但是可以用接口来实现, 这样就用到了implements, 继承只能继承一个类, 但implements可以实现多个接口, 用逗号分开就行了。")]),t._v(" "),a("h2",{attrs:{id:"抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),a("h3",{attrs:{id:"抽象类定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类定义"}},[t._v("#")]),t._v(" 抽象类定义")]),t._v(" "),a("ul",[a("li",[t._v("abstract修饰的类为抽象类,此类不能有对象, (无法对此类进行实例化,说白了就是不能new)")]),t._v(" "),a("li",[t._v("abstract修饰的方法为抽象方法,此方法不能有方法体")])]),t._v(" "),a("h3",{attrs:{id:"知识点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#知识点-2"}},[t._v("#")]),t._v(" 知识点")]),t._v(" "),a("ul",[a("li",[t._v("抽象类不能有对象,不能用new此关键字来创建抽象类的对象;")]),t._v(" "),a("li",[t._v("有抽象方法的类一定是抽象类,但是抽象类中不一定有抽象方法 ;")]),t._v(" "),a("li",[t._v("抽象类中的抽象方法必须在子类中被重写。")])]),t._v(" "),a("h2",{attrs:{id:"接口与抽象类对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口与抽象类对比"}},[t._v("#")]),t._v(" 接口与抽象类对比")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("类型")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("abstract class")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("interface")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("定义")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("关键字abstract 修饰的类")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("关键字interface修饰")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("继承")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("抽象类可以继承一个类和实现多个接口(单继承, 多实现), 子类只可以继承一个抽象类")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("接口只可以继承接口(-个或者多个) ;子类可以实现多个接口")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("访问修饰符")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("抽象类可以有public. protected 和default 这些修饰符(要保证子类可以继承父类)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("接口只能是public (要保证类的实现)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("方法实现")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("可以定义构造方法, 可以有抽象方法和具体方法")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("接口是抽象的, 没有构造方法, 且方法都默认是抽象方法, 但在jdk1.8,接口中的方法可以具体实现, 用default关键字。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("实现方法")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("子类使用extends关键字来继承抽象类。如果子类不是抽象类的话, 它需要提供抽象类中所有声明的方法的实现")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("子类使用implements来实现接口, 子类需要提供接口中所有声明的方法的实现")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("作用")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("把相同的东西提取出来, 即重用")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("把程序模块进行固化的契约, 降低耦合")])])])])])}),[],!1,null,null,null);e.default=i.exports}}]);