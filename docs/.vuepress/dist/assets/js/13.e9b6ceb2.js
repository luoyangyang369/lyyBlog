(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{508:function(t,_,v){"use strict";v.r(_);var e=v(6),r=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000003063859",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux IO模式及 select、poll、epoll详解"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html",target:"_blank",rel:"noopener noreferrer"}},[v("strong",[t._v("IO 模型知多少")]),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://www.jianshu.com/p/fa7bdc4f3de7",target:"_blank",rel:"noopener noreferrer"}},[t._v("程序员应该这样理解 IO"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://snailclimb.gitee.io/javaguide/#/docs/java/basis/IO%E6%A8%A1%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("IO 模型"),v("OutboundLink")],1)])]),t._v(" "),v("h2",{attrs:{id:"有哪些常见的-io-模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常见的-io-模型"}},[t._v("#")]),t._v(" 有哪些常见的 IO 模型?")]),t._v(" "),v("p",[t._v("UNIX 系统下， IO 模型一共有 5 种： "),v("strong",[t._v("同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O")]),t._v("。")]),t._v(" "),v("p",[t._v("这也是我们经常提到的 5 种 IO 模型。")]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("p",[t._v("这 5 种 IO 模型，按照其在两个阶段的特点区分：")]),t._v(" "),v("ul",[v("li",[t._v("阻塞 IO 模型：硬件到系统内核，阻塞。系统内核到程序空间，阻塞。")]),t._v(" "),v("li",[t._v("非阻塞 IO 模型：硬件到系统内核，轮询阻塞。系统内核到程序空间，阻塞。")]),t._v(" "),v("li",[t._v("复用 IO 模型：硬件到系统内核，多流轮询阻塞。系统内核到程序空间，阻塞。")]),t._v(" "),v("li",[t._v("信号驱动 IO 模型：硬件到系统内核，信号回调不阻塞。系统内核到程序空间，阻塞。")]),t._v(" "),v("li",[t._v("异步 IO 模型：硬件到系统内核，信号回调不阻塞。系统内核到程序空间，信号回调不阻塞。")])]),t._v(" "),v("p",[t._v("从上面的 5 种 IO 模型，我们可以看出，真正实现异步非阻塞的只有异步 IO 这种模型，而其他四种都是同步性 IO。因为在第二阶段：从内核缓冲区复制到进程缓冲区的时候，不可能干其他事情。")]),t._v(" "),v("h2",{attrs:{id:"何为-io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#何为-io"}},[t._v("#")]),t._v(" 何为 IO")]),t._v(" "),v("blockquote",[v("blockquote",[v("p",[t._v("理解IO一定要弄清楚所要研究的本体。")])])]),t._v(" "),v("p",[t._v("例如，甲乙两人交谈，甲将大脑中的想法通过声带震动，继而通过声波传入乙的耳朵，乙通过耳膜的震动再由神经将信号解析到大脑，这个数据流动的过程对甲而言是输出，对乙而言是输入。")]),t._v(" "),v("p",[t._v("回到计算机")]),t._v(" "),v("blockquote",[v("p",[t._v("为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 "),v("strong",[t._v("用户空间（User space）")]),t._v(" 和 "),v("strong",[t._v("内核空间（Kernel space ）")]),t._v(" 。")])]),t._v(" "),v("p",[t._v("像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。")]),t._v(" "),v("p",[t._v("并且，用户空间的程序不能直接访问内核空间。")]),t._v(" "),v("p",[t._v("当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。")]),t._v(" "),v("p",[t._v("因此，用户进程想要执行 IO 操作的话，必须通过 "),v("strong",[t._v("系统调用")]),t._v(" 来间接访问内核空间")]),t._v(" "),v("p",[t._v("我们在平常开发过程中接触最多的就是 "),v("strong",[t._v("磁盘 IO（读写文件）")]),t._v(" 和 "),v("strong",[t._v("网络 IO（网络请求和相应）")]),t._v("。")]),t._v(" "),v("blockquote",[v("p",[t._v("从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。")]),t._v(" "),v("p",[t._v("也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。")])]),t._v(" "),v("p",[t._v("当应用程序发起 I/O 调用后，会经历两个步骤：")]),t._v(" "),v("ol",[v("li",[t._v("内核等待 I/O 设备准备好数据")]),t._v(" "),v("li",[t._v("内核将数据从内核空间拷贝到用户空间。")])]),t._v(" "),v("h2",{attrs:{id:"阻塞和非阻塞io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#阻塞和非阻塞io"}},[t._v("#")]),t._v(" 阻塞和非阻塞IO")]),t._v(" "),v("p",[t._v("阻塞和非阻塞强调的是进程对于操作系统IO是否处于就绪状态的处理方式。")]),t._v(" "),v("p",[t._v("上面已经说过，应用程序的IO实际是分为两个步骤，IO调用和IO执行。IO调用是由进程发起，IO执行是操作系统的工作。操作系统的IO情况决定了进程IO调用是否能够得到立即响应。如进程发起了读取数据的IO调用，操作系统需要将外部数据拷贝到进程缓冲区，在有数据拷贝到进程缓冲区前，进程缓冲区处于不可读状态，我们称之为操作系统IO未就绪。")]),t._v(" "),v("p",[t._v("进程的IO调用是否能得到立即执行是需要操作系统IO处于就绪状态的，对于读取数据的操作，如果操作系统IO处于未就绪状态，当前进程或线程如果一直等待直到其就绪，该种IO方式为阻塞IO。如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为非阻塞IO。所以对于非阻塞IO，我们编程时需要经常去轮询就绪状态。")]),t._v(" "),v("h2",{attrs:{id:"异步和同步io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步和同步io"}},[t._v("#")]),t._v(" 异步和同步IO")]),t._v(" "),v("p",[t._v("我们经常会谈及同步IO和异步IO。同步和异步描述的是针对当前执行线程、或进程而言，发起IO调用后，当前线程或进程是否挂起等待操作系统的IO执行完成。")]),t._v(" "),v("p",[t._v("我们说一个IO执行是同步执行的，意思是程序发起IO调用，当前线程或进程需要等待操作系统完成IO工作并告知进程已经完成，线程或进程才能继续往下执行其他既定指令。")]),t._v(" "),v("p",[t._v("如果说一个IO执行是异步的，意思是该动作是由当前线程或进程请求发起，且当前线程或进程不必等待操作系统IO的执行完毕，可直接继续往下执行其他既定指令。操作系统完成IO后，当前线程或进程会得到操作系统的通知。")]),t._v(" "),v("p",[t._v("以一个读取数据的IO操作而言，在操作系统将外部数据写入进程缓冲区这个期间，进程或线程挂起等待操作系统IO执行完成的话，这种IO执行策略就为同步，如果进程或线程并不挂起而是继续工作，这种IO执行策略便为异步。")]),t._v(" "),v("h2",{attrs:{id:"总结-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("p",[t._v("综上，从编程的角度讲述了程序员应该如何去理解IO编程的一些概念。其关键点是要将应用程序的IO操作分为两个步骤来理解：IO调用和IO执行。IO调用才是应用程序干的事情，而IO执行是操作系统的工作。在IO调用时，对待操作系统IO就绪状态的不同方式，决定了其是阻塞或非阻塞模式；在IO执行时，线程或进程是否挂起等待IO执行决定了其是否为同步或异步IO。")]),t._v(" "),v("h2",{attrs:{id:"select"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[t._v("#")]),t._v(" select")]),t._v(" "),v("p",[t._v("缺点：  会遍历俩次 socket")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket。")])]),t._v(" "),v("li",[v("p",[t._v("进程被唤醒后，程序并不知道哪些socket收到数据，还需要遍历一次。")])])]),t._v(" "),v("p",[t._v("总之： poll是翻译轮询的意思，我们可以看到poll和epoll都有轮询的过程。\n不同点在于：")]),t._v(" "),v("p",[t._v("poll轮询的是所有的socket。\n而epoll只轮询就绪的socket。")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/five_io.jpg",alt:"epoll"}})])])}),[],!1,null,null,null);_.default=r.exports}}]);