(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{507:function(s,l,a){"use strict";a.r(l);var r=a(6),_=Object(r.a)({},(function(){var s=this,l=s.$createElement,a=s._self._c||l;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"简述线程、程序、进程的基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简述线程、程序、进程的基本概念"}},[s._v("#")]),s._v(" 简述线程、程序、进程的基本概念")]),s._v(" "),a("p",[a("strong",[s._v("线程")]),s._v(" 与进程相似, 但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源, 所以系统在产生一个线程, 或是在各个线程之间作切换工作时, 负担要比进程小得多, 也正因为如此, 线程也被称为轻量级进程。")]),s._v(" "),a("p",[a("strong",[s._v("程序")]),s._v(" 是含有指令和数据的文件, 被存储在磁盘或其他的数据存储设备中, 也就是说程序是静态的代码。")]),s._v(" "),a("p",[a("strong",[s._v("进程")]),s._v(" 是程序的一次执行过程, 是系统运行程序的基本单位, 因此进程是动态的。系统运行一个程序即是一个进程从创建, 运行到消亡的过程。简单来说, 一个进程就是一个执行中的程序, 它在计算机中一个指令接着一个指令地执行着, 同时, 每个进程还占有某些系统资源如 CPU 时间, 内存空间, 文件, 输入输出设备的使用权等等。换句话说, 当程序在执行时, 将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的, 而各线程则不一定, 因为同一进程中的线程极有可能会相互影响。从另一角度来说, 进程属于操作系统的范畴, 主要是同一段时间内, 可以同时执行一个以上的程序, 而线程则是在同一程序内几乎同时执行一个以上的程序段。")]),s._v(" "),a("h2",{attrs:{id:"线程数和cpu利用率的小总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程数和cpu利用率的小总结"}},[s._v("#")]),s._v(" 线程数和CPU利用率的小总结")]),s._v(" "),a("p",[s._v("上面的例子, 只是辅助, 为了更好的理解线程数/程序行为/CPU状态的关系, 来简单总结一下:\n1、 一个极端的线程(不停执行“计算”型操作时), 就可以把单个核心的利用率跑满, 多核心CPU最多只能同时执行等于核心数的“极端”线程数\n2、 如果每个线程都这么“极端”, 且同时执行的线程数超过核心数, 会导致不必要的切换, 造成负载过高, 只会让执行更慢。\n3、 I/O 等暂停类操作时, CPU处于空闲状态, 操作系统调度CPU执行其他线程, 可以提高CPU利用率, 同时执行更多的线程\n4、 I/O 事件的频率频率越高, 或者等待/暂停时间越长, CPU的空闲时间也就更长, 利用率越低, 操作系统可以调度CPU执行更多的线程")]),s._v(" "),a("h2",{attrs:{id:"阻塞-非阻塞-同步-异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞-非阻塞-同步-异步"}},[s._v("#")]),s._v(" 阻塞/非阻塞 同步/异步")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("阻塞/非阻塞:描述的是调用者调用方法后的状态, 比如:线程A调用了B方法, A线程处于阻塞状态。")])]),s._v(" "),a("li",[a("p",[s._v("同步/异步:描述的方法跟调用者间通信的方式, 如果不需要调用者主动等待, 调用者调用后立即返回, 然后方法本身通过回调, 消息通知等方式通知调用者结果, 就是异步的。如果调用方法后一直需要调用者一直等待方法返回结果, 那么就是同步的")])])]),s._v(" "),a("h2",{attrs:{id:"profile、bashrc、bash-profile之间的区别和联系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#profile、bashrc、bash-profile之间的区别和联系"}},[s._v("#")]),s._v(" profile、bashrc、bash_profile之间的区别和联系")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("/etc/profile")])])]),s._v(" "),a("p",[s._v("系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行并从/etc/profile.d目录的配置文件中搜集shell的设置.\n所以如果你有对/etc/profile有修改的话必须得重启你的修改才会生效, 此修改对每个用户都生效。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("/etc/bashrc")])])]),s._v(" "),a("p",[s._v("为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.\n如果你想对所有的使用bash的用户修改某个配置并在以后打开的bash都生效的话可以修改这个文件, 修改这个文件不用重启, 重新打开一个bash即可生效。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("~/.bash_profile")])])]),s._v(" "),a("p",[s._v("每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.")]),s._v(" "),a("p",[s._v("此文件类似于/etc/profile, 也是需要需要重启才会生效, /etc/profile对所有用户生效, ~/.bash_profile只对当前用户生效。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("~/.bashrc")])])]),s._v(" "),a("p",[s._v("该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.(每个用户都有一个.bashrc文件, 在用户目录下)")]),s._v(" "),a("p",[s._v("此文件类似于/etc/bashrc, 不需要重启生效, 重新打开一个bash即可生效,   /etc/bashrc对所有用户新打开的bash都生效, 但~/.bashrc只对当前用户新打开的bash生效。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("~/.bash_logout")])])]),s._v(" "),a("p",[s._v("当每次退出系统(退出bash shell)时,执行该文件.")]),s._v(" "),a("p",[s._v('另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是"父子"关系.')]),s._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("~/.bash_profile 是交互式、login 方式进入bash 运行的;\n~/.bashrc 是交互式 non-login 方式进入bash 运行的;\n通常二者设置大致相同, 所以通常前者会调用后者。")]),s._v(" "),a("p",[a("strong",[s._v("执行顺序")]),s._v("为:/etc/profile -> (~/.bash_profile | ~/.bash_login | ~/.profile) -> ~/.bashrc -> /etc/bashrc -> ~/.bash_logout")]),s._v(" "),a("h2",{attrs:{id:"shell的交互式和非交互式、登录和非登录的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shell的交互式和非交互式、登录和非登录的区别"}},[s._v("#")]),s._v(" SHELL的交互式和非交互式、登录和非登录的区别")]),s._v(" "),a("p",[s._v("交互式shell和非交互式shell、登录shell和非登录shell的区别。\n首先, 这是两个不同的维度来划分的, 一个是是否交互式, 另一个是是否登录。")]),s._v(" "),a("h3",{attrs:{id:"交互式和非交互式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#交互式和非交互式"}},[s._v("#")]),s._v(" 交互式和非交互式")]),s._v(" "),a("ul",[a("li",[s._v("交互式")])]),s._v(" "),a("p",[s._v("交互式模式就是在终端上执行, shell等待你的输入, 并且立即执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的:登录、执行一些命令、退出。当你退出后, shell也终止了。")]),s._v(" "),a("ul",[a("li",[s._v("非交互式")])]),s._v(" "),a("p",[s._v("以shell script(非交互)方式执行。在这种模式 下, shell不与你进行交互, 而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾EOF, shell也就终止了。")]),s._v(" "),a("p",[s._v("1.3 测试逻辑表达式\n基本格式\n-a : 逻辑与,操作符两边均为真,结果为真,否则为假。\n-o : 逻辑或,操作符两边一边为真,结果为真,否则为假。\n! : 逻辑否,条件为假,结果为真。")])])}),[],!1,null,null,null);l.default=_.exports}}]);