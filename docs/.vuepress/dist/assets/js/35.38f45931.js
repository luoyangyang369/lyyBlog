(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{532:function(e,a,r){"use strict";r.r(a);var t=r(6),v=Object(t.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"简历"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简历"}},[e._v("#")]),e._v(" 简历")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://resume.mdnice.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Markdown简历排版工具"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.wondercv.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("超级简历"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/salomonelli/best-resume-ever",target:"_blank",rel:"noopener noreferrer"}},[e._v("best-resume-ever 基于Vue和LESS快速生成简历模板"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.polebrief.com/index",target:"_blank",rel:"noopener noreferrer"}},[e._v("极简简历"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/Snailclimb/typora-markdown-resume",target:"_blank",rel:"noopener noreferrer"}},[e._v("typora+markdown+css 自定义简历模板"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"常考面试题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常考面试题"}},[e._v("#")]),e._v(" 常考面试题")]),e._v(" "),r("ul",[r("li",[r("p",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/gBr3UfC1HRcw4U-ZMmtRaQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("面试总结"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://draveness.me/mysql-innodb/",target:"_blank",rel:"noopener noreferrer"}},[e._v("『浅入浅出』MySQL 和 InnoDB"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://tech.meituan.com/2014/08/20/innodb-lock.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Innodb中的事务隔离级别和锁的关系"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"http://blog.codinglabs.org/articles/theory-of-mysql-index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MySQL索引背后的数据结构及算法原理"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000008131735",target:"_blank",rel:"noopener noreferrer"}},[e._v("MySQL 性能优化神器 Explain 使用分析"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.cnblogs.com/loveincode/p/7411911.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("论述Redis和Memcached的差异"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"http://www.scienjus.com/redis-use-case/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis应用场景"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453140867&idx=2&sn=5c573be40ff3e897bed2ede542ef8c34&chksm=8cf2d700bb855e166f6c8db7d89185b26139ace92ef70484084ce2abd9a6c9e66eb0f84b9695&scene=178&cur_album_id=1323328139262754819#rd",target:"_blank",rel:"noopener noreferrer"}},[e._v("《吊打面试官》系列-Redis基础"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/EGGe14IpEsho75ntjeR3OA",target:"_blank",rel:"noopener noreferrer"}},[e._v("分布式锁"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://blog.csdn.net/qzcsu/article/details/72861891",target:"_blank",rel:"noopener noreferrer"}},[e._v("彻底明白TCP的三次握手与四次挥手"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000003063859",target:"_blank",rel:"noopener noreferrer"}},[e._v("Linux IO模式及 select、poll、epoll详解"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.lintcode.com/collection/195/",target:"_blank",rel:"noopener noreferrer"}},[e._v("必刷编程80道"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://lc.netlify.app/#/",target:"_blank",rel:"noopener noreferrer"}},[e._v("算法"),r("OutboundLink")],1)])])]),e._v(" "),r("h2",{attrs:{id:"网络"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[e._v("#")]),e._v(" 网络")]),e._v(" "),r("ol",[r("li",[e._v("OSI 与 TCP/IP 各层的结构与功能,都有哪些协议?为什么网络要分层？")]),e._v(" "),r("li",[e._v("计算机网络的一些常见状态码")]),e._v(" "),r("li",[e._v("ping 所使用的协议")]),e._v(" "),r("li",[e._v("TCP 的三次握手与四次挥手的内容？ TCP 为什么连接是三次握手而断开是四次握手？")]),e._v(" "),r("li",[e._v("TCP 与 UDP 的区别及使用场景")]),e._v(" "),r("li",[e._v("TCP 是如何保证传输的可靠性？")]),e._v(" "),r("li",[e._v("一次完整的 HTTP 请求所经的步骤")]),e._v(" "),r("li",[e._v("HTTP 协议了解么？HTTP 是基于 TCP 还是 UDP 的？")]),e._v(" "),r("li",[e._v("HTTP 报文的内容简单说一下！ HTTP 请求报文和响应报文中有哪些数据？")]),e._v(" "),r("li",[e._v("HTTP 和 HTTPS 的区别了解么？")]),e._v(" "),r("li",[e._v("HTTP 请求有哪些常见的状态码？")]),e._v(" "),r("li",[e._v("HTTP 长连接和短连接了解么？")]),e._v(" "),r("li",[e._v("Cookie 和 Session 的关系")]),e._v(" "),r("li",[e._v("URI 和 URL 的区别是什么?")])]),e._v(" "),r("h4",{attrs:{id:"tcp和udp的比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的比较"}},[e._v("#")]),e._v(" TCP和UDP的比较")]),e._v(" "),r("p",[e._v("TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为 对数据准确性要求高，速度可以相对较慢的，可以选用TCP")]),e._v(" "),r("h4",{attrs:{id:"tcp四次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp四次挥手"}},[e._v("#")]),e._v(" TCP四次挥手")]),e._v(" "),r("p",[e._v("（1）：客户端发送终止命令FIN")]),e._v(" "),r("p",[e._v("（2）：服务端收到后回复ACK，处于close_wait状态")]),e._v(" "),r("p",[e._v("（3）：服务器将关闭前需要发送信息发送给客户端后处于last_ack状态")]),e._v(" "),r("p",[e._v("（4）：客户端收到FIN后发送ack后处于tim-wait而后进入close状态")]),e._v(" "),r("h4",{attrs:{id:"为什么要进行第三次握手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么要进行第三次握手"}},[e._v("#")]),e._v(" 为什么要进行第三次握手")]),e._v(" "),r("p",[e._v("为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端")]),e._v(" "),r("h2",{attrs:{id:"redis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[e._v("#")]),e._v(" Redis")]),e._v(" "),r("ol",[r("li",[e._v("Redis 和 Memcached 的区别和共同点")]),e._v(" "),r("li",[e._v("为什么要用 Redis/为什么要用缓存？")]),e._v(" "),r("li",[e._v("Redis 常见数据结构以及使用场景分析")]),e._v(" "),r("li",[e._v("Redis 没有使用多线程？为什么不使用多线程？Redis6.0 之后为何引入了多线程？")]),e._v(" "),r("li",[e._v("Redis 给缓存数据设置过期时间有啥用？")]),e._v(" "),r("li",[e._v("Redis 是如何判断数据是否过期的呢？")]),e._v(" "),r("li",[e._v("过期的数据的删除策略了解么？")]),e._v(" "),r("li",[e._v("Redis 内存淘汰机制了解么？")]),e._v(" "),r("li",[e._v("Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)")]),e._v(" "),r("li",[e._v("Redis 缓存穿透、缓存雪崩？")]),e._v(" "),r("li",[e._v("如何保证缓存和数据库数据的一致性？")])]),e._v(" "),r("h4",{attrs:{id:"redis单线程为什么执行速度这么快"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis单线程为什么执行速度这么快"}},[e._v("#")]),e._v(" redis单线程为什么执行速度这么快?")]),e._v(" "),r("p",[e._v("（1）：纯内存操作，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快")]),e._v(" "),r("p",[e._v("（2）：单线程操作，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗")]),e._v(" "),r("p",[e._v("（3）：采用了非阻塞I/O多路复用机制")]),e._v(" "),r("h4",{attrs:{id:"redis数据结构底层实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis数据结构底层实现"}},[e._v("#")]),e._v(" Redis数据结构底层实现")]),e._v(" "),r("p",[e._v("String：\n（1）Simple dynamic string（SDS）的数据结构")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("struct sdshdr{\n //记录buf数组中已使用字节的数量\n //等于 SDS 保存字符串的长度\n int len；\n //记录 buf 数组中未使用字节的数量\n int free；\n //字节数组，用于保存字符串\n char buf[]；\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br")])]),r("p",[e._v("它的优点：（1）不会出现字符串变更造成的内存溢出问题")]),e._v(" "),r("p",[e._v("（2）获取字符串长度时间复杂度为1")]),e._v(" "),r("p",[e._v("（3）空间预分配， 惰性空间释放free字段，会默认留够一定的空间防止多次重分配内存")]),e._v(" "),r("p",[e._v("应用场景：String 缓存结构体用户信息，计数")]),e._v(" "),r("p",[e._v("Hash：\n数组+链表的基础上，进行了一些rehash优化；1.Reids的Hash采用链地址法来处理冲突，然后它没有使用红黑树优化。")]),e._v(" "),r("p",[e._v("2.哈希表节点采用单链表结构。")]),e._v(" "),r("p",[e._v("3.rehash优化 （采用分而治之的思想，将庞大的迁移工作量划分到每一次CURD中，避免了服务繁忙）")]),e._v(" "),r("p",[e._v("应用场景：保存结构体信息可部分获取不用序列化所有字段")]),e._v(" "),r("p",[e._v("List：\n应用场景：（1）：比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现")]),e._v(" "),r("p",[e._v("（2）：list的实现为一个双向链表，即可以支持反向查找和遍历")]),e._v(" "),r("p",[e._v("Set：\n内部实现是一个 value为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员 是否在集合内的原因。应用场景：去重的场景，交集（sinter）、并集（sunion）、差集（sdiff），实现如共同关注、共同喜好、二度好友等功能")]),e._v(" "),r("p",[e._v("Zset：\n内部使用HashMap和跳跃表（SkipList）来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。跳表：每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的 应用场景：实现延时队列")]),e._v(" "),r("h4",{attrs:{id:"redis事务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis事务"}},[e._v("#")]),e._v(" redis事务")]),e._v(" "),r("p",[e._v("（1）：Multi开启事务")]),e._v(" "),r("p",[e._v("（2）：Exec执行事务块内命令")]),e._v(" "),r("p",[e._v("（3）：Discard 取消事务")]),e._v(" "),r("p",[e._v("（4）：Watch 监视一个或多个key，如果事务执行前key被改动，事务将打断")]),e._v(" "),r("h4",{attrs:{id:"redis事务的实现特征"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis事务的实现特征"}},[e._v("#")]),e._v(" redis事务的实现特征")]),e._v(" "),r("p",[e._v("（1）：所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行")]),e._v(" "),r("p",[e._v("（2）：Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行")]),e._v(" "),r("p",[e._v("（3）：在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行")]),e._v(" "),r("p",[e._v("（4）：当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。")]),e._v(" "),r("p",[e._v("然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。")]),e._v(" "),r("p",[e._v("Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了")]),e._v(" "),r("h4",{attrs:{id:"redis的同步机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis的同步机制"}},[e._v("#")]),e._v(" Redis的同步机制？")]),e._v(" "),r("p",[e._v("（1）：全量拷贝， 1.slave第一次启动时，连接Master，发送PSYNC命令，")]),e._v(" "),r("p",[e._v("2.master会执行bgsave命令来生成rdb文件，期间的所有写命令将被写入缓冲区。")]),e._v(" "),r("p",[e._v("master bgsave执行完毕，向slave发送rdb文件")]),e._v(" "),r("p",[e._v("slave收到rdb文件，丢弃所有旧数据，开始载入rdb文件")]),e._v(" "),r("p",[e._v("rdb文件同步结束之后，slave执行从master缓冲区发送过来的所以写命令。")]),e._v(" "),r("p",[e._v("此后 master 每执行一个写命令，就向slave发送相同的写命令。")]),e._v(" "),r("p",[e._v("（2）：增量拷贝 如果出现网络闪断或者命令丢失等异常情况，从节点之前保存了自身已复制的偏移量和主节点的运行ID")]),e._v(" "),r("p",[e._v("主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。")]),e._v(" "),r("h4",{attrs:{id:"redis集群模式性能优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis集群模式性能优化"}},[e._v("#")]),e._v(" redis集群模式性能优化")]),e._v(" "),r("p",[e._v("（1） Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件")]),e._v(" "),r("p",[e._v("（2） 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次")]),e._v(" "),r("p",[e._v("（3） 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内")]),e._v(" "),r("p",[e._v("（4） 尽量避免在压力很大的主库上增加从库")]),e._v(" "),r("p",[e._v("（5） 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3…这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。")]),e._v(" "),r("h4",{attrs:{id:"redis集群方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis集群方案"}},[e._v("#")]),e._v(" Redis集群方案")]),e._v(" "),r("p",[e._v("（1）：官方cluster方案")]),e._v(" "),r("p",[e._v("（2）：twemproxy")]),e._v(" "),r("p",[e._v("代理方案twemproxy是一个单点，很容易对其造成很大的压力，所以通常会结合keepalived来实twemproy的高可用")]),e._v(" "),r("p",[e._v("（3）：codis 基于客户端来进行分片")]),e._v(" "),r("h4",{attrs:{id:"集群不可用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集群不可用场景"}},[e._v("#")]),e._v(" 集群不可用场景")]),e._v(" "),r("p",[e._v("（1）：master挂掉，且当前master没有slave")]),e._v(" "),r("p",[e._v("（2）：集群超过半数以上master挂掉，无论是否有slave集群进入fail状态")]),e._v(" "),r("h4",{attrs:{id:"redis-最适合的场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-最适合的场景"}},[e._v("#")]),e._v(" redis 最适合的场景")]),e._v(" "),r("p",[e._v("（1）：会话缓存session cache")]),e._v(" "),r("p",[e._v("（2）：排行榜/计数器ZRANGE")]),e._v(" "),r("p",[e._v("（3）：发布/订阅")]),e._v(" "),r("h4",{attrs:{id:"缓存淘汰策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存淘汰策略"}},[e._v("#")]),e._v(" 缓存淘汰策略")]),e._v(" "),r("p",[e._v("（1）：先进先出算法（FIFO）")]),e._v(" "),r("p",[e._v("（2）：最近使用最少Least Frequently Used（LFU）")]),e._v(" "),r("p",[e._v("（3）：最长时间未被使用的Least Recently Used（LRU）")]),e._v(" "),r("p",[e._v("当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重")]),e._v(" "),r("h4",{attrs:{id:"redis过期key删除策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis过期key删除策略"}},[e._v("#")]),e._v(" redis过期key删除策略")]),e._v(" "),r("p",[e._v("（1）：惰性删除，cpu友好，但是浪费cpu资源")]),e._v(" "),r("p",[e._v("（2）：定时删除（不常用）")]),e._v(" "),r("p",[e._v("（3）：定期删除，cpu友好，节省空间")]),e._v(" "),r("h4",{attrs:{id:"缓存雪崩以及处理办法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩以及处理办法"}},[e._v("#")]),e._v(" 缓存雪崩以及处理办法")]),e._v(" "),r("p",[e._v("同一时刻大量缓存失效；")]),e._v(" "),r("p",[e._v("处理方法：\n（1）：缓存数据增加过期标记")]),e._v(" "),r("p",[e._v("（2）：设置不同的缓存失效时间")]),e._v(" "),r("p",[e._v("（3）：双层缓存策略C1为短期，C2为长期")]),e._v(" "),r("p",[e._v("（4）：定时更新策略")]),e._v(" "),r("h4",{attrs:{id:"缓存击穿原因以及处理办法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿原因以及处理办法"}},[e._v("#")]),e._v(" 缓存击穿原因以及处理办法")]),e._v(" "),r("p",[e._v("频繁请求查询系统中不存在的数据导致；")]),e._v(" "),r("p",[e._v("处理方法：\n（1）：cache null策略，查询反馈结果为null仍然缓存这个null结果，设置不超过5分钟过期时间")]),e._v(" "),r("p",[e._v("（2）：布隆过滤器，所有可能存在的数据映射到足够大的bitmap中 google布隆过滤器：基于内存，重启失效不支持大数据量，无法在分布式场景 redis布隆过滤器：可扩展性，不存在重启失效问题，需要网络io，性能低于google")]),e._v(" "),r("h4",{attrs:{id:"redis阻塞原因"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis阻塞原因"}},[e._v("#")]),e._v(" redis阻塞原因")]),e._v(" "),r("p",[e._v("（1）：数据结构使用不合理bigkey")]),e._v(" "),r("p",[e._v("（2）：CPU饱和")]),e._v(" "),r("p",[e._v("（3）：持久化阻塞，rdb fork子线程，aof每秒刷盘等")]),e._v(" "),r("p",[e._v("hot key出现造成集群访问量倾斜解决办法\n（1）：使用本地缓存")]),e._v(" "),r("p",[e._v("（2）：利用分片算法的特性，对key进行打散处理（给hot key加上前缀或者后缀，把一个hotkey 的数量变成 redis 实例个数N的倍数M，从而由访问一个 redis key 变成访问 N * M 个redis key）")]),e._v(" "),r("h4",{attrs:{id:"redis分布式锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁"}},[e._v("#")]),e._v(" Redis分布式锁")]),e._v(" "),r("p",[e._v("2.6版本以后lua脚本保证setnx跟setex进行原子性（setnx之后，未setex，服务挂了，锁不释放） a获取锁，超过过期时间，自动释放锁，b获取到锁执行，a代码执行完remove锁，a和b是一样的key，导致a释放了b的锁。解决办法：remove之前判断value（高并发下value可能被修改，应该用lua来保证原子性）")]),e._v(" "),r("h4",{attrs:{id:"redis如何做持久化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis如何做持久化"}},[e._v("#")]),e._v(" Redis如何做持久化")]),e._v(" "),r("p",[e._v("bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据 ，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来 实 现完整恢复重启之前的状态。")]),e._v(" "),r("h4",{attrs:{id:"对方追问那如果突然机器掉电会怎样"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对方追问那如果突然机器掉电会怎样"}},[e._v("#")]),e._v(" 对方追问那如果突然机器掉电会怎样？")]),e._v(" "),r("p",[e._v("取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据.")]),e._v(" "),r("h4",{attrs:{id:"redis锁续租问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis锁续租问题"}},[e._v("#")]),e._v(" redis锁续租问题?")]),e._v(" "),r("p",[e._v("（1）：基于redis的redission分布式可重入锁RLock，以及配合java集合中lock；")]),e._v(" "),r("p",[e._v("（2）：Redission 内部提供了一个监控锁的看门狗，不断延长锁的有效期，默认检查锁的超时时间是30秒")]),e._v(" "),r("p",[e._v("（3）：此方案的问题：如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master ，slave实例。但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。")]),e._v(" "),r("p",[e._v("接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁 解决办法：只需要将新的redis实例，在一个TTL时间内，对客户端不可用即可，在这个时间内，所有客户端锁将被失效或者自动释放.")]),e._v(" "),r("h4",{attrs:{id:"bgsave的原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bgsave的原理是什么"}},[e._v("#")]),e._v(" bgsave的原理是什么？")]),e._v(" "),r("p",[e._v("fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写进的页面数据会逐渐和子进程分离开来。")]),e._v(" "),r("h4",{attrs:{id:"rdb与aof区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rdb与aof区别"}},[e._v("#")]),e._v(" RDB与AOF区别")]),e._v(" "),r("p",[e._v("（1）：R文件格式紧凑，方便数据恢复，保存rdb文件时父进程会fork出子进程由其完成具体持久化工作，最大化redis性能，恢复大数据集速度更快，只有手动提交save命令或关闭命令时才触发备份操作；")]),e._v(" "),r("p",[e._v("（2）：A记录对服务器的每次写操作（默认1s写入一次），保存数据更完整，在redis重启是会重放这些命令来恢复数据，操作效率高，故障丢失数据更少，但是文件体积更大；")]),e._v(" "),r("p",[e._v("1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？\n使用keys指令可以扫出指定模式的key列表。如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了 ，但是整体所花费的时间会比直接用keys指令长。")]),e._v(" "),r("h4",{attrs:{id:"如何使用redis做异步队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何使用redis做异步队列"}},[e._v("#")]),e._v(" 如何使用Redis做异步队列?")]),e._v(" "),r("p",[e._v("一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。")]),e._v(" "),r("h4",{attrs:{id:"可不可以不用sleep呢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可不可以不用sleep呢"}},[e._v("#")]),e._v(" 可不可以不用sleep呢？")]),e._v(" "),r("p",[e._v("list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。")]),e._v(" "),r("h4",{attrs:{id:"能不能生产一次消费多次呢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#能不能生产一次消费多次呢"}},[e._v("#")]),e._v(" 能不能生产一次消费多次呢？")]),e._v(" "),r("p",[e._v("使用pub/sub主题订阅者模式，可以实现1：N的消息队列。")]),e._v(" "),r("h4",{attrs:{id:"pub-sub有什么缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pub-sub有什么缺点"}},[e._v("#")]),e._v(" pub/sub有什么缺点？")]),e._v(" "),r("p",[e._v("在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。")]),e._v(" "),r("h4",{attrs:{id:"redis如何实现延时队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis如何实现延时队列"}},[e._v("#")]),e._v(" redis如何实现延时队列？")]),e._v(" "),r("p",[e._v("使用sortedset，想要执行时间的时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。")]),e._v(" "),r("h4",{attrs:{id:"为啥redis-zset使用跳跃链表而不用红黑树实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为啥redis-zset使用跳跃链表而不用红黑树实现"}},[e._v("#")]),e._v(" 为啥redis zset使用跳跃链表而不用红黑树实现?")]),e._v(" "),r("p",[e._v("（1）：skiplist的复杂度和红黑树一样，而且实现起来更简单。")]),e._v(" "),r("p",[e._v("（2）：在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表。")]),e._v(" "),r("h2",{attrs:{id:"mysql"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[e._v("#")]),e._v(" MYSQL")]),e._v(" "),r("h4",{attrs:{id:"数据库三范式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库三范式"}},[e._v("#")]),e._v(" 数据库三范式")]),e._v(" "),r("p",[e._v("一：确保每列的原子性")]),e._v(" "),r("p",[e._v("二：非主键列不存在对主键的部分依赖 （要求每个表只描述一件事情）")]),e._v(" "),r("p",[e._v("三：满足第二范式，并且表中的列不存在对非主键列的传递依赖")]),e._v(" "),r("h4",{attrs:{id:"数据库主从复制原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库主从复制原理"}},[e._v("#")]),e._v(" 数据库主从复制原理")]),e._v(" "),r("p",[e._v("（1）：主库db的更新事件（update、insert、delete）被写到binlog")]),e._v(" "),r("p",[e._v("（2）：主库创建一个binlog dump thread线程，把binlog的内容发送到从库")]),e._v(" "),r("p",[e._v("（3）：从库创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log.")]),e._v(" "),r("p",[e._v("（4）：从库还会创建一个SQL线程，从relay log里面读取内容写入到slave的db.")]),e._v(" "),r("h4",{attrs:{id:"复制方式分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复制方式分类"}},[e._v("#")]),e._v(" 复制方式分类")]),e._v(" "),r("p",[e._v("（1）：异步复制（默认） 主库写入binlog日志后即可成功返回客户端，无须等待binlog日志传递给从库的过程，但是一旦主库宕机，就有可能出现丢失数据的情况。")]),e._v(" "),r("p",[e._v("（2）半同步复制：（ 5.5版本之后） （安装半同步复制插件）确保从库接收完成主库传递过来的binlog内容已经写入到自己的relay log（传送log）后才会通知主库上面的等待线程。如果等待超时，则关闭半同步复制，并自动转换为异步复制模式，直到至少有一台从库通知主库已经接收到binlog信息为止")]),e._v(" "),r("h4",{attrs:{id:"存储引擎"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存储引擎"}},[e._v("#")]),e._v(" 存储引擎")]),e._v(" "),r("p",[e._v("（1）：Myiasm是mysql默认的存储引擎，不支持数据库事务，行级锁，外键；插入更新需锁表，效率低，查询速度快，Myisam使用的是非聚集索引")]),e._v(" "),r("p",[e._v("（2）：innodb 支持事务，底层为B+树实现，适合处理多重并发更新操作，普通select都是快照读，快照读不加锁。InnoDb使用的是聚集索引")]),e._v(" "),r("h4",{attrs:{id:"聚集索引"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引"}},[e._v("#")]),e._v(" 聚集索引")]),e._v(" "),r("p",[e._v("（1）：聚集索引就是以主键创建的索引")]),e._v(" "),r("p",[e._v("（2）：每个表只能有一个聚簇索引，因为一个表中的记录只能以一种物理顺序存放，实际的数据页只能按照一颗 B+ 树进行排序")]),e._v(" "),r("p",[e._v("（3）：表记录的排列顺序和与索引的排列顺序一致")]),e._v(" "),r("p",[e._v("（4）：聚集索引存储记录是物理上连续存在")]),e._v(" "),r("p",[e._v("（5）：聚簇索引主键的插入速度要比非聚簇索引主键的插入速度慢很多")]),e._v(" "),r("p",[e._v("（6）：聚簇索引适合排序，非聚簇索引不适合用在排序的场合，因为聚簇索引叶节点本身就是索引和数据按相同顺序放置在一起，索引序即是数据序，数据序即是索引序，所以很快。非聚簇索引叶节点是保留了一个指向数据的指针，索引本身当然是排序的，但是数据并未排序，数据查询的时候需要消耗额外更多的I/O，所以较慢")]),e._v(" "),r("p",[e._v("（7）：更新聚集索引列的代价很高，因为会强制innodb将每个被更新的行移动到新的位置")]),e._v(" "),r("h4",{attrs:{id:"非聚集索引"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#非聚集索引"}},[e._v("#")]),e._v(" 非聚集索引")]),e._v(" "),r("p",[e._v("（1）：除了主键以外的索引")]),e._v(" "),r("p",[e._v("（2）：聚集索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接指向对应数据块")]),e._v(" "),r("p",[e._v("（3）：聚簇索引适合排序，非聚簇索引不适合用在排序的场合")]),e._v(" "),r("p",[e._v("（4）：聚集索引存储记录是物理上连续存在，非聚集索引是逻辑上的连续。")]),e._v(" "),r("h4",{attrs:{id:"使用聚集索引为什么查询速度会变快"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用聚集索引为什么查询速度会变快"}},[e._v("#")]),e._v(" 使用聚集索引为什么查询速度会变快？")]),e._v(" "),r("p",[e._v("使用聚簇索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻")]),e._v(" "),r("h4",{attrs:{id:"建立聚集索引有什么需要注意的地方吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#建立聚集索引有什么需要注意的地方吗"}},[e._v("#")]),e._v(" 建立聚集索引有什么需要注意的地方吗？")]),e._v(" "),r("p",[e._v("在聚簇索引中不要包含经常修改的列，因为码值修改后，数据行必须移动到新的位置，索引此时会重排，会造成很大的资源浪费")]),e._v(" "),r("h4",{attrs:{id:"innodb-表对主键生成策略是什么样的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#innodb-表对主键生成策略是什么样的"}},[e._v("#")]),e._v(" InnoDB 表对主键生成策略是什么样的？")]),e._v(" "),r("p",[e._v("优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id隐藏列作为主键。")]),e._v(" "),r("h4",{attrs:{id:"非聚集索引最多可以有多少个"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#非聚集索引最多可以有多少个"}},[e._v("#")]),e._v(" 非聚集索引最多可以有多少个？")]),e._v(" "),r("p",[e._v("每个表你最多可以建立249个非聚簇索引。非聚簇索引需要大量的硬盘空间和内存")]),e._v(" "),r("h4",{attrs:{id:"btree-与-hash-索引有什么区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#btree-与-hash-索引有什么区别"}},[e._v("#")]),e._v(" BTree 与 Hash 索引有什么区别？")]),e._v(" "),r("p",[e._v("（1）：BTree索引可能需要多次运用折半查找来找到对应的数据块 （2）：HASH索引是通过HASH函数，计算出HASH值，在表中找出对应的数据 （3）：大量不同数据等值精确查询，HASH索引效率通常比B+TREE高 （4）：HASH索引不支持模糊查询、范围查询和联合索引中的最左匹配规则，而这些Btree索引都支持")]),e._v(" "),r("h4",{attrs:{id:"数据库索引优缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库索引优缺点"}},[e._v("#")]),e._v(" 数据库索引优缺点")]),e._v(" "),r("p",[e._v("（1）：需要查询，排序，分组和联合操作的字段适合建立索引")]),e._v(" "),r("p",[e._v("（2）：索引多，数据更新表越慢，尽量使用字段值不重复比例大的字段作为索引，联合索引比多个独立索引效率高")]),e._v(" "),r("p",[e._v("（3）：对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引")]),e._v(" "),r("p",[e._v("（4）：当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。")]),e._v(" "),r("h4",{attrs:{id:"索引的底层实现是b-树-为何不采用红黑树-b树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#索引的底层实现是b-树-为何不采用红黑树-b树"}},[e._v("#")]),e._v(" 索引的底层实现是B+树，为何不采用红黑树，B树?")]),e._v(" "),r("p",[e._v("（1）：B+Tree非叶子节点只存储键值信息，降低B+Tree的高度，所有叶子节点之间都有一个链指针，数据记录都存放在叶子节点中")]),e._v(" "),r("p",[e._v("（2）：红黑树这种结构，h明显要深的多，效率明显比B-Tree差很多")]),e._v(" "),r("p",[e._v("（3）：B+树也存在劣势，由于键会重复出现，因此会占用更多的空间。但是与带来的性能优势相比，空间劣势往往可以接受，因此B+树的在数据库中的使用比B树更加广泛")]),e._v(" "),r("h4",{attrs:{id:"索引失效条件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#索引失效条件"}},[e._v("#")]),e._v(" 索引失效条件")]),e._v(" "),r("p",[e._v("（1）：条件是or，如果还想让or条件生效，给or每个字段加个索引")]),e._v(" "),r("p",[e._v("（2）：like开头%")]),e._v(" "),r("p",[e._v("（3）：如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引")]),e._v(" "),r("p",[e._v("（4）：where中索引列使用了函数或有运算")]),e._v(" "),r("h4",{attrs:{id:"数据库事务特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务特点"}},[e._v("#")]),e._v(" 数据库事务特点")]),e._v(" "),r("p",[e._v("ACID 原子性，一致性，隔离性，永久性")]),e._v(" "),r("p",[e._v("数据库事务说是如何实现的?\n（1）：通过预写日志方式实现的，redo和undo机制是数据库实现事务的基础")]),e._v(" "),r("p",[e._v("（2）：redo日志用来在断电/数据库崩溃等状况发生时重演一次刷数据的过程，把redo日志里的数据刷到数据库里，保证了事务 的持久性（Durability）")]),e._v(" "),r("p",[e._v("（3）：undo日志是在事务执行失败的时候撤销对数据库的操作，保证了事务的原子性")]),e._v(" "),r("h4",{attrs:{id:"数据库事务隔离级别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务隔离级别"}},[e._v("#")]),e._v(" 数据库事务隔离级别")]),e._v(" "),r("p",[e._v("（1）：读未提交read-uncommitted-- 脏，不可重复读--幻读 A读取了B未提交的事务，B回滚，A 出现脏读；")]),e._v(" "),r("p",[e._v("（2）：不可重复读read-committed-- 不可重复读--幻读 A只能读B已提交的事务，但是A还没结束，B又更新数据隐式提交，然后A又读了一次出现不可重复读；")]),e._v(" "),r("p",[e._v("（3）：可重复读repeatable-read<默认>-- 幻读 事务开启，不允许其他事务的UPDATE修改操作 A读取B已提交的事务，然而B在该表插入新的行，之后A在读取的时候多出一行，出现幻读；")]),e._v(" "),r("p",[e._v("（4）：串行化serializable--")]),e._v(" "),r("h4",{attrs:{id:"不可重复读和幻读的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读和幻读的区别"}},[e._v("#")]),e._v(" 不可重复读和幻读的区别")]),e._v(" "),r("p",[e._v("很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。")]),e._v(" "),r("p",[e._v("如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。")]),e._v(" "),r("p",[e._v("所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。")]),e._v(" "),r("p",[e._v("上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。")]),e._v(" "),r("h4",{attrs:{id:"七种事务传播行为"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#七种事务传播行为"}},[e._v("#")]),e._v(" 七种事务传播行为")]),e._v(" "),r("p",[e._v("（1）Propagation.REQUIRED<默认> 如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。")]),e._v(" "),r("p",[e._v("（2）Propagation.SUPPORTS 如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。")]),e._v(" "),r("p",[e._v("（3）Propagation.MANDATORY 如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。")]),e._v(" "),r("p",[e._v("（4）Propagation.REQUIRES_NEW 重新创建一个新的事务，如果当前存在事务，延缓当前的事务。")]),e._v(" "),r("p",[e._v("（5）Propagation.NOT_SUPPORTED 以非事务的方式运行，如果当前存在事务，暂停当前的事务。")]),e._v(" "),r("p",[e._v("（6）Propagation.NEVER 以非事务的方式运行，如果当前存在事务，则抛出异常。")]),e._v(" "),r("p",[e._v("（7）Propagation.NESTED 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。")]),e._v(" "),r("h4",{attrs:{id:"产生死锁的四个必要条件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#产生死锁的四个必要条件"}},[e._v("#")]),e._v(" 产生死锁的四个必要条件")]),e._v(" "),r("p",[e._v("（1）：互斥：资源x的任意一个时刻只能被一个线程持有\n（2）：占有且等待：线程1占有资源x的同时等待资源y，并不释放x\n（3）：不可抢占：资源x一旦被线程1占有，其他线程不能抢占x\n（4）：循环等待：线程1持有x，等待y，线程2持有y，等待x 当全部满足时才会死锁")]),e._v(" "),r("h4",{attrs:{id:"transaction"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#transaction"}},[e._v("#")]),e._v(" @Transaction")]),e._v(" "),r("p",[e._v("底层实现是AOP，动态代理 （1）：实现是通过Spring代理来实现的。生成当前类的代理类，调用代理类的invoke（）方法，在invoke（）方法中调用 TransactionInterceptor拦截器的invoke（）方法；")]),e._v(" "),r("p",[e._v("（2）：非public方式其事务是失效的；")]),e._v(" "),r("p",[e._v("（3）：自调用也会失效，因为动态代理机制导致")]),e._v(" "),r("p",[e._v("（4）多个方法外层加入try...catch，解决办法是可以在catch里 throw new RuntimeException（）来处理")]),e._v(" "),r("h2",{attrs:{id:"java-并发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-并发"}},[e._v("#")]),e._v(" Java 并发")]),e._v(" "),r("ol",[r("li",[e._v("什么是线程和进程? 线程与进程的关系,区别及优缺点？")]),e._v(" "),r("li",[e._v("说说并发与并行的区别?")]),e._v(" "),r("li",[e._v("为什么要使用多线程呢?")]),e._v(" "),r("li",[e._v("使用多线程可能带来什么问题?（内存泄漏、死锁、线程不安全等等）")]),e._v(" "),r("li",[e._v("创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）")]),e._v(" "),r("li",[e._v("说说线程的生命周期和状态?")]),e._v(" "),r("li",[e._v("什么是上下文切换?")]),e._v(" "),r("li",[e._v("什么是线程死锁?如何避免死锁?")]),e._v(" "),r("li",[e._v("说说 sleep() 方法和 wait() 方法区别和共同点?")]),e._v(" "),r("li",[e._v("Java 内存模型（JMM）、重排序与 happens-before 原则了解吗？s")]),e._v(" "),r("li",[e._v("ynchronized 关键字、volatile 关键字")]),e._v(" "),r("li",[e._v("ThreadLocal 有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？")]),e._v(" "),r("li",[e._v("为什么要用线程池？ThreadPoolExecutor 类的重要参数了解吗？ThreadPoolExecutor 饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗？为什么不推荐使用FixedThreadPool？如何设置线程池的大小？")]),e._v(" "),r("li",[e._v("AQS 了解么？原理？AQS 常用组件：Semaphore (信号量)、CountDownLatch （倒计时器） CyclicBarrier(循环栅栏)")]),e._v(" "),r("li",[e._v("ReentrantLock 、 ReentrantReadWriteLock 、StampedLock（JDK8）")]),e._v(" "),r("li",[e._v("CAS 了解么？原理？")]),e._v(" "),r("li",[e._v("Atomic 原子类")]),e._v(" "),r("li",[e._v("并发容器：ConcurrentHashMap 、 CopyOnWriteArrayList 、 ConcurrentLinkedQueue BlockingQueue 、ConcurrentSkipListMap")]),e._v(" "),r("li",[e._v("Future 和 CompletableFuture")])])])}),[],!1,null,null,null);a.default=v.exports}}]);