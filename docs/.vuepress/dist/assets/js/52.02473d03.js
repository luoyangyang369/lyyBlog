(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{546:function(t,a,e){"use strict";e.r(a);var r=e(6),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h4",{attrs:{id:"synchronized-与-reentrantlock-比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-与-reentrantlock-比较"}},[t._v("#")]),t._v(" synchronized 与 ReentrantLock 比较")]),t._v(" "),e("h5",{attrs:{id:"比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#比较"}},[t._v("#")]),t._v(" 比较")]),t._v(" "),e("ul",[e("li",[t._v("锁的实现")])]),t._v(" "),e("p",[t._v("synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。")]),t._v(" "),e("ul",[e("li",[t._v("性能")])]),t._v(" "),e("p",[t._v("新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。")]),t._v(" "),e("ul",[e("li",[t._v("等待可中断")])]),t._v(" "),e("p",[t._v("当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。")]),t._v(" "),e("p",[t._v("ReentrantLock 可中断，而 synchronized 不行。")]),t._v(" "),e("ul",[e("li",[t._v("公平锁")])]),t._v(" "),e("p",[t._v("公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。")]),t._v(" "),e("p",[t._v("synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。")]),t._v(" "),e("ul",[e("li",[t._v("锁绑定多个条件")])]),t._v(" "),e("p",[t._v("一个 ReentrantLock 可以同时绑定多个 Condition 对象。")]),t._v(" "),e("h5",{attrs:{id:"使用选择"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用选择"}},[t._v("#")]),t._v(" 使用选择")]),t._v(" "),e("p",[t._v("除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放")]),t._v(" "),e("h4",{attrs:{id:"wait-和-sleep-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#wait-和-sleep-的区别"}},[t._v("#")]),t._v(" wait() 和 sleep() 的区别")]),t._v(" "),e("p",[t._v("wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； wait() 会释放锁，sleep() 不会。")]),t._v(" "),e("h4",{attrs:{id:"锁优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁优化"}},[t._v("#")]),t._v(" 锁优化")]),t._v(" "),e("p",[t._v("这里的锁优化主要是指 JVM 对 synchronized 的优化。")]),t._v(" "),e("h6",{attrs:{id:"自旋锁-cas"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁-cas"}},[t._v("#")]),t._v(" 自旋锁 CAS")]),t._v(" "),e("blockquote",[e("p",[t._v("CAS（Compare and swap），即比较并交换，也是实现我们平时所说的自旋锁或乐观锁的核心操作。\n互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是"),e("strong",[t._v("让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间")]),t._v("，如果在这段时间内能获得锁，就可以避免进入阻塞状态。")])]),t._v(" "),e("p",[t._v("自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，"),e("strong",[t._v("它只适用于共享数据的锁定状态很短的场景。")])]),t._v(" "),e("p",[t._v("在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。")]),t._v(" "),e("h6",{attrs:{id:"锁消除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁消除"}},[t._v("#")]),t._v(" 锁消除")]),t._v(" "),e("p",[t._v("锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。")]),t._v(" "),e("p",[t._v("锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。")]),t._v(" "),e("h6",{attrs:{id:"锁粗化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁粗化"}},[t._v("#")]),t._v(" 锁粗化")]),t._v(" "),e("p",[t._v("如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。")]),t._v(" "),e("p",[t._v("如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。")]),t._v(" "),e("h6",{attrs:{id:"轻量级锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁"}},[t._v("#")]),t._v(" 轻量级锁")]),t._v(" "),e("p",[t._v("JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。")]),t._v(" "),e("p",[t._v("以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。")]),t._v(" "),e("p",[t._v("轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。")]),t._v(" "),e("p",[t._v("当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。")]),t._v(" "),e("p",[t._v("如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。")]),t._v(" "),e("h6",{attrs:{id:"偏向锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[t._v("#")]),t._v(" 偏向锁")]),t._v(" "),e("p",[t._v("偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。")]),t._v(" "),e("p",[t._v("当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。")]),t._v(" "),e("p",[t._v("当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。")])])}),[],!1,null,null,null);a.default=v.exports}}]);