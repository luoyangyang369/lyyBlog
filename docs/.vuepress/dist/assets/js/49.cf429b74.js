(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{544:function(a,s,e){"use strict";e.r(s);var l=e(6),t=Object(l.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[a._v("#")]),a._v(" 参考资料")]),a._v(" "),e("h2",{attrs:{id:"与-equals-重要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与-equals-重要"}},[a._v("#")]),a._v(" == 与 equals(重要)")]),a._v(" "),e("p",[a._v("== : 它的作用是判断两个对象的地址是不是相等。即, 判断两个对象是不是同一个对象(基本数据类型==比较的是值, 引用数据类型==比较的是内存地址)。")]),a._v(" "),e("p",[a._v("equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况:")]),a._v(" "),e("ul",[e("li",[a._v("情况 1:类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时, 等价于通过“==”比较这两个对象。")]),a._v(" "),e("li",[a._v("情况 2:类覆盖了 equals() 方法。一般, 我们都覆盖 equals() 方法来比较两个对象的内容是否相等;若它们的内容相等, 则返回 true (即, 认为这两个对象相等)。")])]),a._v(" "),e("h2",{attrs:{id:"hashcode-与-equals"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashcode-与-equals"}},[a._v("#")]),a._v(" hashCode 与 equals")]),a._v(" "),e("p",[a._v("hashCode()与 equals() 的相关规定：")]),a._v(" "),e("ol",[e("li",[a._v("如果两个对象相等，则 hashcode 一定也是相同的")]),a._v(" "),e("li",[a._v("两个对象相等，对两个 equals() 方法返回 true")]),a._v(" "),e("li",[a._v("两个对象有相同的 hashcode 值，它们也不一定是相等的")])]),a._v(" "),e("h2",{attrs:{id:"关于-final-关键字的一些总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于-final-关键字的一些总结"}},[a._v("#")]),a._v(" 关于 final 关键字的一些总结")]),a._v(" "),e("p",[a._v("final 关键字主要用在三个地方:变量、方法、类。")]),a._v(" "),e("p",[a._v("1、 对于一个 final 变量, 如果是基本数据类型的变量, 则其数值一旦在初始化之后便不能更改;如果是引用类型的变量, 则在对其初始化之后便不能再让其指向另一个对象。\n2、 当用 final 修饰一个类时, 表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。\n3、使用 final 方法的原因有两个。第一个原因是把方法锁定, 以防任何继承类修改它的含义;第二个原因是效率。在早期的 Java 实现版本中, 会将 final 方法转为内嵌调用。但是如果方法过于庞大, 可能看不到内嵌调用带来的任何性能提升(现在的 Java 版本已经不需要使用 final 方法进行这些优化了)。类中所有的 private 方法都隐式地指定为 final。")])])}),[],!1,null,null,null);s.default=t.exports}}]);