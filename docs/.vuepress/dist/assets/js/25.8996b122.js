(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{520:function(t,_,a){"use strict";a.r(_);var v=a(6),r=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"innodb-自增-auto-increment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb-自增-auto-increment"}},[t._v("#")]),t._v(" innodb 自增 auto_increment")]),t._v(" "),a("p",[t._v('Innodb引擎的自增值, 是保存在内存中的, 并且到了mysql8.0版本后, 才有了“自增值持久化”的能力, 也就是才实现了"如果发生重启, 表的自增值可以恢复为mysql重启前的值"')]),t._v(" "),a("p",[t._v("mysql8.0后自增值的变更记录在了redo log中, 重启的时候依靠redo log恢复重启之前的值")]),t._v(" "),a("h3",{attrs:{id:"为什么自增不连续原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么自增不连续原因"}},[t._v("#")]),t._v(" 为什么自增不连续原因")]),t._v(" "),a("p",[t._v("参数innodb_autoinc_lock_mode = 1时, 每次会“预申请”多余的id(handler.cc:compute_next_insert_id), 而insert执行完成后, 会特别将这些预留的id空出, 就是特意将预申请后的当前最大id回写到表中")]),t._v(" "),a("p",[t._v("所以导致ID不连续的原因是因为innodb_autoinc_lock_mode = 1时, 会多申请id。好处是:一次性分配足够的auto_increment id, 只会将整个分配的过程锁住。")]),t._v(" "),a("h2",{attrs:{id:"为什么大多数生产环境不用外键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么大多数生产环境不用外键"}},[t._v("#")]),t._v(" 为什么大多数生产环境不用外键")]),t._v(" "),a("p",[t._v("其实这个话题是老生常谈, 很多人在工作中确实也不会使用外键。包括在阿里的JAVA规范中也有下面这一条")]),t._v(" "),a("ul",[a("li",[t._v("【强制】不得使用外键与级联, 一切外键概念必须在应用层解决。")])]),t._v(" "),a("p",[t._v("但是呢, 询问他们原因, 大多是这么回答的")]),t._v(" "),a("ul",[a("li",[t._v("每次做DELETE 或者UPDATE都必须考虑外键约束, 会导致开发的时候很痛苦,测试数据极为不方便。")])]),t._v(" "),a("ol",[a("li",[t._v("性能损耗")]),t._v(" "),a("li",[t._v("迁移数据时候的一致性维护")])]),t._v(" "),a("p",[t._v("这么说也是对的。下面详细说明")]),t._v(" "),a("h3",{attrs:{id:"正文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[t._v("#")]),t._v(" 正文")]),t._v(" "),a("p",[t._v("首先我们明确一点, 外键约束是一种约束, 这个约束的存在, 会保证表间数据的关系“始终完整”。因此, 外键约束的存在, 并非全然没有优点。\n比如使用外键, 可以")]),t._v(" "),a("ul",[a("li",[t._v("保证数据的完整性和一致性")]),t._v(" "),a("li",[t._v("级联操作方便")]),t._v(" "),a("li",[t._v("将数据完整性判断托付给了数据库完成, 减少了程序的代码量")])]),t._v(" "),a("p",[t._v("然而, 鱼和熊掌不可兼得。外键是能够保证数据的完整性, 但是会给系统带来很多缺陷。正是因为这些缺陷, 才导致我们不推荐使用外键, 具体如下:")]),t._v(" "),a("h4",{attrs:{id:"性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能问题"}},[t._v("#")]),t._v(" 性能问题")]),t._v(" "),a("p",[t._v("假设一张表名为user_tb。那么这张表里有两个外键字段, 指向两张表。那么, 每次往user_tb表里插入数据, 就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制, 这种查询过程就可以控制在我们手里, 可以省略一些不必要的查询过程。但是如果由数据库控制, 则是必须要去这两张表里判断。")]),t._v(" "),a("h4",{attrs:{id:"并发问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发问题"}},[t._v("#")]),t._v(" 并发问题")]),t._v(" "),a("p",[t._v("在使用外键的情况下, 每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。若是在高并发大流量事务场景, 使用外键更容易造成死锁。")]),t._v(" "),a("h4",{attrs:{id:"扩展性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展性问题"}},[t._v("#")]),t._v(" 扩展性问题")]),t._v(" "),a("p",[t._v("这里主要是分为两点")]),t._v(" "),a("p",[t._v("做平台迁移方便, 比如你从Mysql迁移到Oracle, 像触发器、外键这种东西, 都可以利用框架本身的特性来实现, 而不用依赖于数据库本身的特性, 做迁移更加方便。\n分库分表方便, 在水平拆分和分库的情况下, 外键是无法生效的。将数据间关系的维护, 放入应用程序中, 为将来的分库分表省去很多的麻烦。\n技术问题\n使用外键, 其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点, 数据库的性能开销变大了, 那么这就对DBA的要求就更高了。很多中小型公司由于资金问题, 并没有聘用专业的DBA, 因此他们会选择不用外键, 降低数据库的消耗。\n相反的, 如果该约束逻辑在应用程序中, 发现应用服务器性能不够, 可以加机器, 做水平扩展。如果是在数据库服务器上, 数据库服务器会成为性能瓶颈, 做水平扩展比较困难。")]),t._v(" "),a("h2",{attrs:{id:"为什么一定要设一个主键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么一定要设一个主键"}},[t._v("#")]),t._v(" 为什么一定要设一个主键？")]),t._v(" "),a("p",[a("strong",[t._v("回答:")]),t._v(" 因为你不设主键的情况下, innodb也会帮你生成一个隐藏列, 作为自增主键。所以啦, 反正都要生成一个主键, 那你还不如自己指定一个主键, 在有些情况下, 就能显式的用上主键索引, 提高查询效率！")]),t._v(" "),a("h2",{attrs:{id:"主键是用自增还是uuid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主键是用自增还是uuid"}},[t._v("#")]),t._v(" 主键是用自增还是UUID?")]),t._v(" "),a("p",[a("strong",[t._v("回答:")]),t._v(" 肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的, 那么每次插入新的记录, 记录就会顺序添加到当前索引节点的后续位置, 当一页写满, 就会自动开辟一个新的页。如果不是自增主键, 那么可能会在中间插入, 就会引发页的分裂, 产生很多表碎片！  "),a("strong",[t._v("简单说用自增插入性能好！")])]),t._v(" "),a("h4",{attrs:{id:"补充"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[t._v("#")]),t._v(" 补充")]),t._v(" "),a("p",[t._v("UUID缺点:")]),t._v(" "),a("ol",[a("li",[t._v("影响插入速度,  并且造成硬盘使用率低")]),t._v(" "),a("li",[t._v("uuid之间比较大小相对于自增id比较大小要慢很多,  影响查询速度。")]),t._v(" "),a("li",[t._v("uuid占空间大,  如果你建的索引越多,  影响越严重")])]),t._v(" "),a("p",[t._v("UUID优点:出现数据拆分、合并存储的时候, 能达到全局的唯一性(比如:历史数据表的主键id会与数据表的id重复, 两张自增id做主键的表合并时, id一定会有冲突, 但如果各自的id还关联了其他表, 这就很不好操作。而使用UUID, 生成的ID不仅是表独立的, 而且是库独立的。)")]),t._v(" "),a("ul",[a("li",[t._v("在分布式环境下可使用UUID, 自增合并表时会发生id重复的问题, 但也可设置自增的间隔")])]),t._v(" "),a("h5",{attrs:{id:"自增id用完怎么办"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自增id用完怎么办"}},[t._v("#")]),t._v(" 自增ID用完怎么办？")]),t._v(" "),a("p",[a("strong",[t._v("回答:")]),t._v(" 戳 => "),a("a",{attrs:{href:"https://www.cnblogs.com/rjzheng/p/10669043.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("this"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"主键为什么不推荐有业务含义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主键为什么不推荐有业务含义"}},[t._v("#")]),t._v(" 主键为什么不推荐有业务含义?")]),t._v(" "),a("p",[a("strong",[t._v("回答:")]),t._v(" 有如下两个原因")]),t._v(" "),a("p",[t._v("(1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义, 那么主键就有可能发生变更。主键一旦发生变更, 该数据在磁盘上的存储位置就会发生变更, 有可能会引发页分裂, 产生空间碎片。")]),t._v(" "),a("p",[t._v("(2)带有业务含义的主键, 不一定是顺序自增的。那么就会导致数据的插入顺序, 并不能保证后面插入数据的主键一定比前面的数据大。如果出现了, 后面插入数据的主键比前面的小, 就有可能引发页分裂, 产生空间碎片。")]),t._v(" "),a("h2",{attrs:{id:"表示枚举的字段为什么不用enum类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表示枚举的字段为什么不用enum类型"}},[t._v("#")]),t._v(" 表示枚举的字段为什么不用enum类型？")]),t._v(" "),a("p",[a("strong",[t._v("回答:")]),t._v(" 在工作中表示枚举的字段, 一般用tinyint类型。\n那为什么不用enum类型呢？下面两个原因")]),t._v(" "),a("p",[t._v("(1)ENUM类型的ORDER BY操作效率低, 需要额外操作\n(2)如果枚举值是数值, 有陷阱")]),t._v(" "),a("h2",{attrs:{id:"货币字段用什么类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#货币字段用什么类型"}},[t._v("#")]),t._v(" 货币字段用什么类型?")]),t._v(" "),a("p",[a("strong",[t._v("回答:")]),t._v(" 如果货币单位是分, 可以用Int类型。如果坚持用元, 用Decimal。\n千万不要答float和double, 因为float和double是以二进制存储的, 所以有一定的误差。")]),t._v(" "),a("h2",{attrs:{id:"时间字段用什么类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间字段用什么类型"}},[t._v("#")]),t._v(" 时间字段用什么类型?")]),t._v(" "),a("p",[a("strong",[t._v("回答:")]),t._v(" 此题无固定答案, 应结合自己项目背景来答！把理由讲清楚就行！")]),t._v(" "),a("p",[t._v("(1)varchar, 如果用varchar类型来存时间, 优点在于显示直观。但是坑的地方也是挺多的。比如, 插入的数据没有校验, 你可能某天就发现一条数据为2013111的数据, 请问这是代表2013年1月11日, 还是2013年11月1日？\n其次, 做时间比较运算, 你需要用STR_TO_DATE等函数将其转化为时间类型, 你会发现这么写是无法命中索引的。数据量一大, 是个坑！")]),t._v(" "),a("p",[t._v("(2)timestamp, 该类型是四个字节的整数, 它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间, 是无法用timestamp类型存储的。\n但是它有一个优势, timestamp类型是带有时区信息的。一旦你系统中的时区发生改变, 例如你修改了时区")]),t._v(" "),a("p",[t._v('SET TIME_ZONE = "america/new_york";\n你会发现, 项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目, 跨时区的应用时, 特别注意！')]),t._v(" "),a("p",[t._v("(3)datetime, datetime储存占用8个字节, 它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然, 存储时间范围更大。但是它坑的地方在于, 他存储的是时间绝对值, 不带有时区信息。如果你改变数据库的时区, 该项的值不会自己发生变更！")]),t._v(" "),a("p",[t._v("(4)bigint, 也是8个字节, 自己维护一个时间戳, 表示范围比timestamp大多了, 就是要自己维护, 不大方便。")]),t._v(" "),a("h2",{attrs:{id:"为什么不直接存储图片、音频、视频等大容量内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不直接存储图片、音频、视频等大容量内容"}},[t._v("#")]),t._v(" 为什么不直接存储图片、音频、视频等大容量内容?")]),t._v(" "),a("p",[a("strong",[t._v("回答:")]),t._v(" 我们在实际应用中, 都是用HDFS来存储文件。然后mysql中, 只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件, 也就是text和blob类型。但是, 我们在生产中, 基本不用这两个类型！\n主要原因有如下两点")]),t._v(" "),a("p",[t._v("(1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型, 如果查询中包含这样的数据, 在排序等操作时, 就不能使用内存临时表, 必须使用磁盘临时表进行。导致查询效率缓慢\n(2)binlog内容太多。因为你数据内容比较大, 就会造成binlog内容比较多。大家也知道, 主从同步是靠binlog进行同步, binlog太大了, 就会导致主从同步效率问题！\n因此, 不推荐使用text和blob类型！")]),t._v(" "),a("h2",{attrs:{id:"字段为什么要定义为not-null"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字段为什么要定义为not-null"}},[t._v("#")]),t._v(" 字段为什么要定义为NOT NULL?")]),t._v(" "),a("p",[a("strong",[t._v("回答:")]),t._v("\n(1)索引性能不好\nMysql难以优化引用可空列查询, 它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间, 还需要mysql内部进行特殊处理。可空列被索引后, 每条记录都需要一个额外的字节, 还能导致MYisam 中固定大小的索引变成可变大小的索引。\n—— 出自《高性能mysql第二版》")]),t._v(" "),a("p",[t._v("(2)查询会出现一些不可预料的结果\n这里举一个例子, 大家就懂了。假设, 表结构如下")])])}),[],!1,null,null,null);_.default=r.exports}}]);