(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{528:function(v,_,t){"use strict";t.r(_);var s=t(6),l=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"带着问题看答案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#带着问题看答案"}},[v._v("#")]),v._v(" 带着问题看答案")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("如何保证缓存与数据库的一致性")])]),v._v(" "),t("li",[t("p",[v._v("更新的时候为什么是删除缓存，而不是更新缓存？")])]),v._v(" "),t("li",[t("p",[v._v("更新缓存 VS 淘汰缓存")])]),v._v(" "),t("li",[t("p",[v._v("先操作数据库 vs 先操作缓存")])]),v._v(" "),t("li",[t("p",[v._v("缓存架构的优化")])]),v._v(" "),t("li",[t("p",[v._v("缓存架构的结论强调")])]),v._v(" "),t("li",[t("p",[v._v("为什么缓存 和 数据库会不一致")])]),v._v(" "),t("li",[t("p",[v._v("不一致的优化思路")])]),v._v(" "),t("li",[t("p",[v._v("提问：任务队列已经做了任务队列串行化的工作，能否保证任务不并发执行？")])]),v._v(" "),t("li",[t("p",[v._v("提问：假设服务只部署一份，能否保证任我游不并发执行？")])]),v._v(" "),t("li",[t("p",[v._v("提问：假设1个服务只有一条数据库连接，能否保证任务不并发执行？")])]),v._v(" "),t("li",[t("p",[v._v("提问：假设服务只有1份，且只有1条数据库连接，能否保证任务不并发执行？")])])]),v._v(" "),t("p",[v._v("解决方案：让数据库的访问能 “串行化” 就行 多服务部署，上述方案就不可用 同一数据的访问落到同一个服务器上？\n总结，改造连接池，解决数据不一致的问题 提问：取模是否会影响服务的可用性 提问：取模访问服务与取模访问DB,是否会影响各连接上的请求的负载均 衡？ 数据库主从不一致，怎么解？\n提问：要是数据库的架构做了主从同步，读写分离\n提问：常见的数据库集群架构如何？ 为什么会出现不一致？ 如何避免这种主从延时导致的不一致？\n总结：数据库主库和从库不一致，常见有这么几种优化方案： 比较经典的做法就是：缓存 + 数据库读写模式")]),v._v(" "),t("ol",[t("li",[v._v("查询的时候：先读缓存，缓存没有读数据库，然后取出数据库的数据，放入缓存， 返回响应。")]),v._v(" "),t("li",[v._v("更新的时候：先更新数据库，然后在删除缓存。")])]),v._v(" "),t("h2",{attrs:{id:"更新的时候为什么是删除缓存-而不是更-新缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更新的时候为什么是删除缓存-而不是更-新缓存"}},[v._v("#")]),v._v(" 更新的时候为什么是删除缓存，而不是更 新缓存？")]),v._v(" "),t("p",[v._v("一个比较耗时缓存计算场景，如果你频繁修改某个表的数据，每次都涉这个缓存更 新，但是这个缓存在这段时间内都不会被用到。")]),v._v(" "),t("p",[v._v("例子：一个缓存涉及的表字段，在1分钟被修改20次，那么缓存也更新20次，但是这 个缓存在1分钟内，只有被读取到1次，有大量的冷数据。")]),v._v(" "),t("p",[v._v("实际上，如果你删除了这个缓存的话，那么在1分钟内内，只有被读取这个缓存的时候 计算1次，并且写入缓存。开销大幅度降低，用到才去缓存，就是懒加载思想。")]),v._v(" "),t("h2",{attrs:{id:"更新缓存-vs-淘汰缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更新缓存-vs-淘汰缓存"}},[v._v("#")]),v._v(" 更新缓存 VS 淘汰缓存")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("更新缓存")]),v._v("：数据不但写入数据库，还会写入缓存")]),v._v(" "),t("li",[t("strong",[v._v("淘汰缓存")]),v._v("：数据只会写入数据库，不会写入缓存，只会把缓存删除掉")])]),v._v(" "),t("p",[t("strong",[v._v("更新缓存的优点")]),v._v("： 缓存的命中率高，不会因为缓存没有去查询数据库\n"),t("strong",[v._v("淘汰缓存的优点")]),v._v("：简单，直接删除缓存啊")]),v._v(" "),t("blockquote",[t("p",[v._v("那么到底是更新缓存，还是淘汰缓存？")])]),v._v(" "),t("p",[t("strong",[v._v("取决于“更新缓存的复杂度”")]),v._v("，比如更新缓存的内容需要复杂查询计算，那么淘汰缓存 就更适合")]),v._v(" "),t("h2",{attrs:{id:"先操作数据库-vs-先操作缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#先操作数据库-vs-先操作缓存"}},[v._v("#")]),v._v(" 先操作数据库 vs 先操作缓存")]),v._v(" "),t("p",[v._v("当写操作发生时，假设淘汰缓存作为对缓存通用的处理方式，那么又面临着两种选择")]),v._v(" "),t("ol",[t("li",[v._v("先写数据库，再淘汰缓存")]),v._v(" "),t("li",[v._v("写淘汰缓存，再写数据库 怎么选择")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("先淘汰缓存，再写数据库 ？")])])]),v._v(" "),t("p",[v._v("对于一个不能保证事务性的操作时，一定涉及 “那个任务先做，那个任务后做” 的问 题，解决这个问题的方向是：")]),v._v(" "),t("blockquote",[t("p",[v._v("如果出现数据不一致，谁先做对业务的影响小，就先执行谁")])]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("假设先写数据库，再淘汰缓存")]),v._v("：第一步写数据库操作成功，第二步淘汰缓存失败， 则会出现 db 中是新数据，cache 中是旧数据，数据不一致了，"),t("strong",[v._v("这是属于原子性被破坏，导致的不一致")])]),v._v(" "),t("li",[t("strong",[v._v("假设先淘汰缓存，在写数据库")]),v._v("：第一步淘汰储存成功，第二部写数据库失败，则会 出现数据库中是旧的，缓存是空的，只会引起一次 Cache miss 【这就是所谓的数据 未命中“miss”】（就是缓存没有数据时候，重新查询数据库，写入缓存）")])]),v._v(" "),t("blockquote",[t("blockquote",[t("p",[v._v("结论：数据库和缓存的操作顺序，是很清楚的：先淘汰缓存，再写数据库。")])])])])}),[],!1,null,null,null);_.default=l.exports}}]);