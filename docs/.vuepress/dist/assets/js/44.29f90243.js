(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{541:function(t,r,_){"use strict";_.r(r);var e=_(6),v=Object(e.a)({},(function(){var t=this,r=t.$createElement,_=t._self._c||r;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"相关概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相关概念"}},[t._v("#")]),t._v(" 相关概念")]),t._v(" "),_("p",[_("strong",[t._v("QPS")]),t._v(": Queries Per Second意思是“每秒查询率”, 是一台服务器每秒能够相应的查询次数, 是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。")]),t._v(" "),_("p",[_("strong",[t._v("TPS")]),t._v(": 是TransactionsPerSecond的缩写, 也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时, 收到服务器响应后结束计时, 以此来计算使用的时间和完成的事务个数。")]),t._v(" "),_("p",[_("strong",[t._v("吞吐量")]),t._v(": 一个系统的吞度量(承压能力)与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高, 外部系统接口、IO影响速度越慢, 系统吞吐能力越低, 反之越高。")]),t._v(" "),_("p",[t._v("是指在一次性能测试过程中网络上传输的数据量的总和。但一般指指系统在单位时间内处理请求的数量")]),t._v(" "),_("p",[_("strong",[t._v("吞吐率")]),t._v(": 特指Web服务器单位时间内处理的请求数。")]),t._v(" "),_("p",[t._v("系统吞吐量几个重要参数:")]),t._v(" "),_("ul",[_("li",[t._v("QPS(TPS):每秒钟request/事务 数量")]),t._v(" "),_("li",[t._v("并发数: 系统同时处理的request/事务数")]),t._v(" "),_("li",[t._v("响应时间:  一般取平均响应时间")])]),t._v(" "),_("p",[t._v("理解了上面三个要素的意义之后, 就能推算出它们之间的关系:\nQPS(TPS)= 并发数/平均响应时间    或者   并发数 = QPS*平均响应时间")]),t._v(" "),_("h2",{attrs:{id:"消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),_("h3",{attrs:{id:"简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),_("p",[t._v("消息队列的主要特点是异步处理, 主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时(同步)返回结果的操作作为消息放入消息队列。")]),t._v(" "),_("p",[t._v("同时由于使用了消息队列, 只要保证消息格式不变, 消息的发送方和接收方并不需要彼此联系, 也不需要受对方的影响, 即解耦和。")]),t._v(" "),_("p",[t._v("CMQ/CKafka/MQ for IoT本质上都属于分布式消息中间件, 分布式消息系统的最大特点是可扩展性。核心理念是多个节点协同工作完成单个节点无法完成的任务, 不允许出现单节点故障服务不可用(RTO)和数据丢失(RPO)情况。归根结底是解决CAP问题, CMQ作为金融级别服务要求数据高可靠强一致(CP), CKafka以大数据领域为主要服务对象, 更偏重于AP,同时允许用户通过配置在CAP之间进行权衡")]),t._v(" "),_("h3",{attrs:{id:"使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("服务解耦")]),t._v(": 多应用间通过消息队列对同一消息进行处理, 避免调用接口失败导致整个过程失败;")]),t._v(" "),_("li",[_("strong",[t._v("异步处理")]),t._v(": 多应用对消息队列中同一消息进行处理, 应用间并发处理消息, 相比串行处理, 减少处理时间。如用户注册后, 需要发送注册邮件和发送注册信息, 传统的做法有两种:串行方式、并行方式")]),t._v(" "),_("li",[_("strong",[t._v("削峰限流")]),t._v(": 广泛应用于秒杀或抢购活动中, 避免流量过大导致应用系统挂掉的情况;")]),t._v(" "),_("li",[_("strong",[t._v("广播订阅")]),t._v(": 发送方不关心谁订阅这个消息, 只管发出来, 拓展方便;")]),t._v(" "),_("li",[t._v("流式数据过滤: 消费者通过类似SQL语句来筛选自己感兴趣的数据;")]),t._v(" "),_("li",[t._v("两阶段消息: 通过两阶段消息与本地数据库事务相结合达到简单分布式事务。")])]),t._v(" "),_("h3",{attrs:{id:"两种消息模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#两种消息模型"}},[t._v("#")]),t._v(" 两种消息模型")]),t._v(" "),_("h4",{attrs:{id:"p2p-point-to-point"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#p2p-point-to-point"}},[t._v("#")]),t._v(" P2P(Point to Point)")]),t._v(" "),_("p",[t._v("P2P模式包含三个角色:消息队列(Queue), 发送者(Sender), 接收者(Receiver)。每个消息都被发送到一个特定的队列, 接收者从队列中获取消息。队列保留着消息, 直到他们被消费或超时。")]),t._v(" "),_("p",[t._v("P2P的特点:")]),t._v(" "),_("ul",[_("li",[t._v("每个消息只有一个消费者(Consumer)(即一旦被消费, 消息就不再在消息队列中)")]),t._v(" "),_("li",[t._v("发送者和接收者之间在时间上没有依赖性, 也就是说当发送者发送了消息之后, 不管接收者有没有正在运行, 它不会影响到消息被发送到队列")]),t._v(" "),_("li",[t._v("接收者在成功接收消息之后需向队列应答成功")])]),t._v(" "),_("h4",{attrs:{id:"publish-subscribe-pub-sub"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#publish-subscribe-pub-sub"}},[t._v("#")]),t._v(" Publish/Subscribe(Pub/Sub)")]),t._v(" "),_("p",[t._v("包含三个角色:主题(Topic), 发布者(Publisher), 订阅者(Subscriber) 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。")]),t._v(" "),_("p",[t._v("Pub/Sub的特点:")]),t._v(" "),_("ul",[_("li",[t._v("每个消息可以有多个消费者")]),t._v(" "),_("li",[t._v("发布者和订阅者之间有时间上的依赖性。针对某个主题(Topic)的订阅者, 它必须创建一个订阅者之后, 才能消费发布者的消息。")]),t._v(" "),_("li",[t._v("为了消费消息, 订阅者必须保持运行的状态。")]),t._v(" "),_("li",[t._v("为了缓和这样严格的时间相关性, JMS允许订阅者创建一个可持久化的订阅。这样, 即使订阅者没有被激活(运行), 它也能接收到发布者的消息。")]),t._v(" "),_("li",[t._v("如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话, 那么可以采用Pub/Sub模型。")])]),t._v(" "),_("h2",{attrs:{id:"cmq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cmq"}},[t._v("#")]),t._v(" CMQ")]),t._v(" "),_("p",[t._v("消息队列 CMQ 支持 Pull(队列) 和 Push(主题) 两种方式:")]),t._v(" "),_("ul",[_("li",[t._v("Push 模型:当 Producer 发出的消息到达后, 服务端马上将这条消息投递给 Consumer。")]),t._v(" "),_("li",[t._v("Pull 模型:当服务端收到这条消息后什么也不做, 只是等着 Consumer 主动到自己这里来读, 即 Consumer 这里有一个“拉取”的动作。")])]),t._v(" "),_("h3",{attrs:{id:""}},[_("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),_("h2",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://ruby-china.org/topics/26221",target:"_blank",rel:"noopener noreferrer"}},[t._v("吞吐量、QPS、TPS"),_("OutboundLink")],1),t._v(" "),_("a",{attrs:{href:"https://www.jianshu.com/p/689ce4205021",target:"_blank",rel:"noopener noreferrer"}},[t._v("消息队列简介"),_("OutboundLink")],1),t._v(" "),_("a",{attrs:{href:"https://cloud.tencent.com/document/api/406/5851",target:"_blank",rel:"noopener noreferrer"}},[t._v("CMQ API"),_("OutboundLink")],1),t._v(" "),_("a",{attrs:{href:"https://cloud.tencent.com/document/product/406",target:"_blank",rel:"noopener noreferrer"}},[t._v("CMQ 文档中心"),_("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=v.exports}}]);