(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{533:function(_,v,a){"use strict";a.r(v);var t=a(6),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247496769&idx=1&sn=30990d141185303fd0c7ecf63c125b30&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[_._v("图解 MySQL 事务"),a("OutboundLink")],1)]),_._v(" "),a("h3",{attrs:{id:"数据库三范式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库三范式"}},[_._v("#")]),_._v(" 数据库三范式")]),_._v(" "),a("ol",[a("li",[_._v("确保每列的原子性")]),_._v(" "),a("li",[_._v("非主键列不存在对主键的部分依赖 （要求每个表只描述一件事情）")]),_._v(" "),a("li",[_._v("满足第二范式，并且表中的列不存在对非主键列的传递依赖")])]),_._v(" "),a("h3",{attrs:{id:"数据库主从复制原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库主从复制原理"}},[_._v("#")]),_._v(" 数据库主从复制原理")]),_._v(" "),a("ol",[a("li",[_._v("主库db的更新事件（update、insert、delete）被写到binlog")]),_._v(" "),a("li",[_._v("主库创建一个binlog dump thread线程，把binlog的内容发送到从库")]),_._v(" "),a("li",[_._v("从库创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log.")]),_._v(" "),a("li",[_._v("从库还会创建一个SQL线程，从relay log里面读取内容写入到slave的db.")])]),_._v(" "),a("h3",{attrs:{id:"复制方式分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制方式分类"}},[_._v("#")]),_._v(" 复制方式分类")]),_._v(" "),a("ul",[a("li",[_._v("异步复制（默认）")])]),_._v(" "),a("p",[_._v("主库写入binlog日志后即可成功返回客户端，无须等待binlog日志传递给从库的过程，但是一旦主库宕机，就有可能出现丢失数据的情况。")]),_._v(" "),a("ul",[a("li",[_._v("半同步复制：（ 5.5版本之后） （安装半同步复制插件）")])]),_._v(" "),a("p",[_._v("确保从库接收完成主库传递过来的binlog内容已经写入到自己的relay log（传送log）后才会通知主库上面的等待线程。如果等待超时，则关闭半同步复制，并自动转换为异步复制模式，直到至少有一台从库通知主库已经接收到binlog信息为止")]),_._v(" "),a("h3",{attrs:{id:"存储引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储引擎"}},[_._v("#")]),_._v(" 存储引擎")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("Myiasm是mysql默认的存储引擎，不支持数据库事务，行级锁，外键；插入更新需锁表，效率低，查询速度快，Myisam使用的是非聚集索引")])]),_._v(" "),a("li",[a("p",[_._v("innodb 支持事务，底层为B+树实现，适合处理多重并发更新操作，普通select都是快照读，快照读不加锁。InnoDb使用的是聚集索引")])])]),_._v(" "),a("h4",{attrs:{id:"为什么用-b-树-而不是-b-树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么用-b-树-而不是-b-树"}},[_._v("#")]),_._v(" 为什么用 b+ 树， 而不是 B 树")]),_._v(" "),a("blockquote",[a("p",[_._v("简单说就是: 减少磁盘 seek 次数。")])]),_._v(" "),a("p",[_._v("选择用b+树作为索引而不是b树作为索引的核心点在于，在存储同等数据量级的情况下，选择用b+树做索引时，要比用b树做索引。平均的磁盘IO次数要少。同时对b+树而言，不同请求的时间复杂度都比较平均。因为每条记录的数据都保存在叶子节点上。")]),_._v(" "),a("h4",{attrs:{id:"mysql-默认的存储引擎选择-b-树而不是哈希或者-b-树的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-默认的存储引擎选择-b-树而不是哈希或者-b-树的原因"}},[_._v("#")]),_._v(" MySQL 默认的存储引擎选择 B+ 树而不是哈希或者 B 树的原因：")]),_._v(" "),a("ul",[a("li",[_._v("哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；")]),_._v(" "),a("li",[_._v("B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O；")])]),_._v(" "),a("h4",{attrs:{id:"影响硬盘性能的因素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#影响硬盘性能的因素"}},[_._v("#")]),_._v(" 影响硬盘性能的因素")]),_._v(" "),a("p",[_._v("影响磁盘的关键因素是磁盘服务时间，即磁盘完成一个I/O请求所花费的时间，它由寻道时间、旋转延迟和数据传输时间三部分构成。")]),_._v(" "),a("ol",[a("li",[a("p",[_._v("寻道时间\nTseek是指将读写磁头移动至正确的磁道上所需要的时间。寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3-15ms。")])]),_._v(" "),a("li",[a("p",[_._v("旋转延迟\nTrotation是指盘片旋转将请求数据所在的扇区移动到读写磁盘下方所需要的时间。旋转延迟取决于磁盘转速，通常用磁盘旋转一周所需时间的1/2表示。比如：7200rpm的磁盘平均旋转延迟大约为60*1000/7200/2 = 4.17ms，而转速为15000rpm的磁盘其平均旋转延迟为2ms。")])]),_._v(" "),a("li",[a("p",[_._v("数据传输时间\nTtransfer是指完成传输所请求的数据所需要的时间，它取决于数据传输率，其值等于数据大小除以数据传输率。目前IDE/ATA能达到133MB/s，SATA II可达到300MB/s的接口数据传输率，数据传输时间通常远小于前两部分消耗时间。简单计算时可忽略。")])])]),_._v(" "),a("ul",[a("li",[_._v("衡量性能的指标")])]),_._v(" "),a("p",[_._v("机械硬盘的连续读写性能很好，但随机读写性能很差，这主要是因为磁头移动到正确的磁道上需要时间，随机读写时，磁头需要不停的移动，时间都浪费在了磁头寻址上，所以性能不高。衡量磁盘的重要主要指标是IOPS和吞吐量。")]),_._v(" "),a("blockquote",[a("p",[a("strong",[_._v("总结")]),_._v("： 采用 B+ 树是因为 seek 时间短。 原因是 B+树 是有序的，所以每次寻道是按照顺序，不需要寻道。")])]),_._v(" "),a("h3",{attrs:{id:"聚集索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引"}},[_._v("#")]),_._v(" 聚集索引")]),_._v(" "),a("ol",[a("li",[_._v("聚集索引就是以主键创建的索引")]),_._v(" "),a("li",[_._v("每个表只能有一个聚簇索引，因为一个表中的记录只能以一种物理顺序存放，实际的数据页只能按照一颗 B+ 树进行排序")]),_._v(" "),a("li",[_._v("表记录的排列顺序和与索引的排列顺序一致")]),_._v(" "),a("li",[_._v("聚集索引存储记录是物理上连续存在")]),_._v(" "),a("li",[_._v("聚簇索引主键的插入速度要比非聚簇索引主键的插入速度慢很多")]),_._v(" "),a("li",[_._v("聚簇索引适合排序，非聚簇索引不适合用在排序的场合，因为聚簇索引叶节点本身就是索引和数据按相同顺序放置在一起，索引序即是数据序，数据序即是索引序，所以很快。非聚簇索引叶节点是保留了一个指向数据的指针，索引本身当然是排序的，但是数据并未排序，数据查询的时候需要消耗额外更多的I/O，所以较慢")]),_._v(" "),a("li",[_._v("更新聚集索引列的代价很高，因为会强制innodb将每个被更新的行移动到新的位置")])]),_._v(" "),a("h3",{attrs:{id:"非聚集索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非聚集索引"}},[_._v("#")]),_._v(" 非聚集索引")]),_._v(" "),a("ol",[a("li",[_._v("除了主键以外的索引")]),_._v(" "),a("li",[_._v("聚集索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接指向对应数据块")]),_._v(" "),a("li",[_._v("聚簇索引适合排序，非聚簇索引不适合用在排序的场合")]),_._v(" "),a("li",[_._v("聚集索引存储记录是物理上连续存在，非聚集索引是逻辑上的连续。")])]),_._v(" "),a("h3",{attrs:{id:"聚集索引和辅助索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引和辅助索引"}},[_._v("#")]),_._v(" 聚集索引和辅助索引")]),_._v(" "),a("p",[_._v("数据库中的 B+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），它们之间的最大区别就是，聚集索引中存放着一条行记录的全部信息，而辅助索引中只包含索引列和一个用于查找对应行记录的『书签』。")]),_._v(" "),a("h3",{attrs:{id:"使用聚集索引为什么查询速度会变快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用聚集索引为什么查询速度会变快"}},[_._v("#")]),_._v(" 使用聚集索引为什么查询速度会变快？")]),_._v(" "),a("p",[_._v("使用聚簇索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻")]),_._v(" "),a("h3",{attrs:{id:"建立聚集索引有什么需要注意的地方吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建立聚集索引有什么需要注意的地方吗"}},[_._v("#")]),_._v(" 建立聚集索引有什么需要注意的地方吗？")]),_._v(" "),a("p",[_._v("在聚簇索引中不要包含经常修改的列，因为码值修改后，数据行必须移动到新的位置，索引此时会重排，会造成很大的资源浪费")]),_._v(" "),a("h3",{attrs:{id:"innodb-表对主键生成策略是什么样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb-表对主键生成策略是什么样的"}},[_._v("#")]),_._v(" InnoDB 表对主键生成策略是什么样的？")]),_._v(" "),a("p",[_._v("优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id隐藏列作为主键。")]),_._v(" "),a("h3",{attrs:{id:"非聚集索引最多可以有多少个"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非聚集索引最多可以有多少个"}},[_._v("#")]),_._v(" 非聚集索引最多可以有多少个？")]),_._v(" "),a("p",[_._v("每个表你最多可以建立249个非聚簇索引。非聚簇索引需要大量的硬盘空间和内存")]),_._v(" "),a("h3",{attrs:{id:"btree-与-hash-索引有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#btree-与-hash-索引有什么区别"}},[_._v("#")]),_._v(" BTree 与 Hash 索引有什么区别？")]),_._v(" "),a("p",[_._v("（1）：BTree索引可能需要多次运用折半查找来找到对应的数据块 （2）：HASH索引是通过HASH函数，计算出HASH值，在表中找出对应的数据 （3）：大量不同数据等值精确查询，HASH索引效率通常比B+TREE高 （4）：HASH索引不支持模糊查询、范围查询和联合索引中的最左匹配规则，而这些Btree索引都支持")]),_._v(" "),a("h3",{attrs:{id:"数据库索引优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库索引优缺点"}},[_._v("#")]),_._v(" 数据库索引优缺点")]),_._v(" "),a("p",[_._v("（1）：需要查询，排序，分组和联合操作的字段适合建立索引")]),_._v(" "),a("p",[_._v("（2）：索引多，数据更新表越慢，尽量使用字段值不重复比例大的字段作为索引，联合索引比多个独立索引效率高")]),_._v(" "),a("p",[_._v("（3）：对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引")]),_._v(" "),a("p",[_._v("（4）：当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。")]),_._v(" "),a("h4",{attrs:{id:"索引的底层实现是b-树-为何不采用红黑树-b树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引的底层实现是b-树-为何不采用红黑树-b树"}},[_._v("#")]),_._v(" 索引的底层实现是B+树，为何不采用红黑树，B树?")]),_._v(" "),a("p",[_._v("（1）：B+Tree非叶子节点只存储键值信息，降低B+Tree的高度，所有叶子节点之间都有一个链指针，数据记录都存放在叶子节点中")]),_._v(" "),a("p",[_._v("（2）：红黑树这种结构，h明显要深的多，效率明显比B-Tree差很多")]),_._v(" "),a("p",[_._v("（3）：B+树也存在劣势，由于键会重复出现，因此会占用更多的空间。但是与带来的性能优势相比，空间劣势往往可以接受，因此B+树的在数据库中的使用比B树更加广泛")]),_._v(" "),a("h4",{attrs:{id:"索引失效条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引失效条件"}},[_._v("#")]),_._v(" 索引失效条件")]),_._v(" "),a("p",[_._v("（1）：条件是or，如果还想让or条件生效，给or每个字段加个索引")]),_._v(" "),a("p",[_._v("（2）：like开头%")]),_._v(" "),a("p",[_._v("（3）：如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引")]),_._v(" "),a("p",[_._v("（4）：where中索引列使用了函数或有运算")]),_._v(" "),a("h4",{attrs:{id:"数据库事务特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务特点"}},[_._v("#")]),_._v(" 数据库事务特点")]),_._v(" "),a("p",[_._v("ACID 原子性，一致性，隔离性，永久性")]),_._v(" "),a("p",[_._v("InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？")]),_._v(" "),a("ul",[a("li",[_._v("原子性和持久性是通过 redo log （重做日志）来保证的；")]),_._v(" "),a("li",[_._v("一致性是通过 undo log（回滚日志） 来保证的；")]),_._v(" "),a("li",[_._v("隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；")])]),_._v(" "),a("h4",{attrs:{id:"数据库事务隔离级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务隔离级别"}},[_._v("#")]),_._v(" 数据库事务隔离级别")]),_._v(" "),a("ul",[a("li",[_._v("脏读: 如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。")]),_._v(" "),a("li",[_._v("不可重复读: 在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。")]),_._v(" "),a("li",[_._v("幻读: 在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。")])]),_._v(" "),a("p",[_._v("SQL 标准提出了四种隔离级别来规避这些现象，隔离级别约高，性能效率就越低，这四个隔离级别如下：")]),_._v(" "),a("ul",[a("li",[_._v("读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到； 可能发生脏读、不可重复读和幻读现象；")]),_._v(" "),a("li",[_._v("读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到； 可能发生不可重复读和幻读现象，但是不可能发生脏读现象；")]),_._v(" "),a("li",[_._v("可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； 可能发生幻读现象，但是不可能脏读和不可重复读现象；")]),_._v(" "),a("li",[_._v("串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行； 脏读、不可重复读和幻读现象都不可能会发生。")])]),_._v(" "),a("blockquote",[a("p",[_._v("InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它通过next-key lock 锁（行锁和间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。")])]),_._v(" "),a("h4",{attrs:{id:"不可重复读和幻读的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读和幻读的区别"}},[_._v("#")]),_._v(" 不可重复读和幻读的区别")]),_._v(" "),a("p",[_._v("很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。")]),_._v(" "),a("p",[_._v("如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。")]),_._v(" "),a("p",[_._v("所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。")]),_._v(" "),a("p",[_._v("上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。")]),_._v(" "),a("h4",{attrs:{id:"七种事务传播行为"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七种事务传播行为"}},[_._v("#")]),_._v(" 七种事务传播行为")]),_._v(" "),a("p",[_._v("（1）Propagation.REQUIRED<默认> 如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。")]),_._v(" "),a("p",[_._v("（2）Propagation.SUPPORTS 如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。")]),_._v(" "),a("p",[_._v("（3）Propagation.MANDATORY 如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。")]),_._v(" "),a("p",[_._v("（4）Propagation.REQUIRES_NEW 重新创建一个新的事务，如果当前存在事务，延缓当前的事务。")]),_._v(" "),a("p",[_._v("（5）Propagation.NOT_SUPPORTED 以非事务的方式运行，如果当前存在事务，暂停当前的事务。")]),_._v(" "),a("p",[_._v("（6）Propagation.NEVER 以非事务的方式运行，如果当前存在事务，则抛出异常。")]),_._v(" "),a("p",[_._v("（7）Propagation.NESTED 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。")]),_._v(" "),a("h4",{attrs:{id:"产生死锁的四个必要条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#产生死锁的四个必要条件"}},[_._v("#")]),_._v(" 产生死锁的四个必要条件")]),_._v(" "),a("p",[_._v("（1）：互斥：资源x的任意一个时刻只能被一个线程持有\n（2）：占有且等待：线程1占有资源x的同时等待资源y，并不释放x\n（3）：不可抢占：资源x一旦被线程1占有，其他线程不能抢占x\n（4）：循环等待：线程1持有x，等待y，线程2持有y，等待x 当全部满足时才会死锁")]),_._v(" "),a("h4",{attrs:{id:"transaction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transaction"}},[_._v("#")]),_._v(" @Transaction")]),_._v(" "),a("p",[_._v("底层实现是AOP，动态代理 （1）：实现是通过Spring代理来实现的。生成当前类的代理类，调用代理类的invoke（）方法，在invoke（）方法中调用 TransactionInterceptor拦截器的invoke（）方法；")]),_._v(" "),a("p",[_._v("（2）：非public方式其事务是失效的；")]),_._v(" "),a("p",[_._v("（3）：自调用也会失效，因为动态代理机制导致")]),_._v(" "),a("p",[_._v("（4）多个方法外层加入try...catch，解决办法是可以在catch里 throw new RuntimeException（）来处理")])])}),[],!1,null,null,null);v.default=r.exports}}]);