(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{529:function(t,e,a){"use strict";a.r(e);var l=a(6),i=Object(l.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("Java 集合类、接口、抽象类介绍\n")]),t._v(" "),a("h2",{attrs:{id:"常用集合分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用集合分类"}},[t._v("#")]),t._v(" 常用集合分类")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/jihemap.png",alt:"常用集合分类"}})]),t._v(" "),a("h3",{attrs:{id:"hashmap-和-hashtable-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-和-hashtable-的区别"}},[t._v("#")]),t._v(" HashMap 和 HashTable 的区别")]),t._v(" "),a("ul",[a("li",[t._v("HashMap")])]),t._v(" "),a("p",[t._v("简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("HashTable")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("HashMap")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("基于Dictionany类")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("基于AbstractMap类")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("key和value都不允许为null, Hashtable遇到null， 直接返回NullPointerException")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("key和value都允许为nill, HashMap遇到key为nl的时候，调用putForNullkey方法进行处理。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("线程安全几乎所有的public的方法都是synchronized的")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("非线程安全")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("速度慢")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("速度快")])])])]),t._v(" "),a("h3",{attrs:{id:"hashmap-和-linkedhashmap-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-和-linkedhashmap-的区别"}},[t._v("#")]),t._v(" HashMap 和 LinkedHashMap 的区别")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("HashMap")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("LinkedHashMap")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("无序存储")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("有序存储，以双向链表实现")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("读取速度与容量有关")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("读取速度与容量无关")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("线程不安全")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("线程不安全")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("key-value都允许null")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("key-value都允许null")])])])]),t._v(" "),a("h3",{attrs:{id:"hashmap-和-treemap-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-和-treemap-的区别"}},[t._v("#")]),t._v(" HashMap 和 TreeMap 的区别")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("HashMap")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("TreeMap")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("遍历出来数据无序")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("自然排序或者创建映射提供的Comparator进行排序")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("基于散列表")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("红黑树")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("取值速度快")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("取值速度慢")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("适用于在Map中插入、删除和定位元素")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("适用于按自然顺序或自定义顺序遍历键(key)")])])])]),t._v(" "),a("h2",{attrs:{id:"interface-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interface-接口"}},[t._v("#")]),t._v(" interface(接口)")]),t._v(" "),a("h3",{attrs:{id:"接口定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口定义"}},[t._v("#")]),t._v(" 接口定义")]),t._v(" "),a("p",[t._v("接口就是一个规范和抽象类比较相似。它只管做什么,不管怎么做。通俗的讲,接口就是某个事物对外提供的一\n些功能的声明,其定义和类比较相似,只不过是通过interface关键字来完成")]),t._v(" "),a("h3",{attrs:{id:"知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#知识点"}},[t._v("#")]),t._v(" 知识点")]),t._v(" "),a("ul",[a("li",[t._v("接口中的所有属性默认为: public static final *** (属性不能够被更改) ;")]),t._v(" "),a("li",[t._v("接口中的所有方法默认为: public abstract **** (方法默认为抽象方法,实现类必须去重写接口中的方法) ;")]),t._v(" "),a("li",[t._v("接口不再像类-样用关键字extends去“继承”, 而是用implements去“实现”, 也就是说类和接口的关系\n叫做实现")])]),t._v(" "),a("h3",{attrs:{id:"接口实现的注意点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口实现的注意点"}},[t._v("#")]),t._v(" 接口实现的注意点")]),t._v(" "),a("ul",[a("li",[t._v("实现一个接口就是要实现该接口的所有的方法(抽象类除外)。")]),t._v(" "),a("li",[t._v("接口中的方法都是抽象的。")]),t._v(" "),a("li",[t._v("多个无关的类可以实现同一个接口，一个类可以实现多个无关的接口。")])]),t._v(" "),a("h3",{attrs:{id:"extends与implements的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extends与implements的区别"}},[t._v("#")]),t._v(" extends与implements的区别")]),t._v(" "),a("p",[t._v("extends 是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承，JAVA中不支持多重继承，但是可以用接口来实现，这样就用到了implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了。")]),t._v(" "),a("h2",{attrs:{id:"抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),a("h3",{attrs:{id:"抽象类定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类定义"}},[t._v("#")]),t._v(" 抽象类定义")]),t._v(" "),a("ul",[a("li",[t._v("abstract修饰的类为抽象类,此类不能有对象，(无法对此类进行实例化,说白了就是不能new)")]),t._v(" "),a("li",[t._v("abstract修饰的方法为抽象方法,此方法不能有方法体")])]),t._v(" "),a("h3",{attrs:{id:"知识点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#知识点-2"}},[t._v("#")]),t._v(" 知识点")]),t._v(" "),a("ul",[a("li",[t._v("抽象类不能有对象,不能用new此关键字来创建抽象类的对象;")]),t._v(" "),a("li",[t._v("有抽象方法的类一定是抽象类,但是抽象类中不一定有抽象方法 ;")]),t._v(" "),a("li",[t._v("抽象类中的抽象方法必须在子类中被重写。")])]),t._v(" "),a("h2",{attrs:{id:"接口与抽象类对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口与抽象类对比"}},[t._v("#")]),t._v(" 接口与抽象类对比")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("类型")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("abstract class")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("interface")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("定义")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("关键字abstract 修饰的类")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("关键字interface修饰")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("继承")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("抽象类可以继承一个类和实现多个接口(单继承，多实现), 子类只可以继承一个抽象类")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("接口只可以继承接口(-个或者多个) ;子类可以实现多个接口")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("访问修饰符")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("抽象类可以有public. protected 和default 这些修饰符(要保证子类可以继承父类)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("接口只能是public (要保证类的实现)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("方法实现")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("可以定义构造方法，可以有抽象方法和具体方法")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("接口是抽象的，没有构造方法，且方法都默认是抽象方法，但在jdk1.8,接口中的方法可以具体实现，用default关键字。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("实现方法")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("子类使用implements来实现接口，子类需要提供接口中所有声明的方法的实现")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("作用")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("把相同的东西提取出来，即重用")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("把程序模块进行固化的契约，降低耦合")])])])])])}),[],!1,null,null,null);e.default=i.exports}}]);