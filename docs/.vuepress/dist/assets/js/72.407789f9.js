(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{569:function(n,t,a){"use strict";a.r(t);var s=a(6),v=Object(s.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126033120%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88%E5%9B%BE.jpg",target:"_blank",rel:"noopener noreferrer"}},[n._v("总览图"),a("OutboundLink")],1),n._v(" "),a("a",{attrs:{href:"https://github.com/wangzheng0822/algo/tree/master/python",target:"_blank",rel:"noopener noreferrer"}},[n._v("wangzheng GitHub"),a("OutboundLink")],1),n._v(" "),a("a",{attrs:{href:"https://visualgo.net/en",target:"_blank",rel:"noopener noreferrer"}},[n._v("各种排序演示图"),a("OutboundLink")],1),n._v(" "),a("a",{attrs:{href:"https://www.bilibili.com/video/av685670",target:"_blank",rel:"noopener noreferrer"}},[n._v("b站学习"),a("OutboundLink")],1)]),n._v(" "),a("h2",{attrs:{id:"是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[n._v("#")]),n._v(" 是什么")]),n._v(" "),a("ol",[a("li",[n._v("数据结构是指一组数据的存储结构")]),n._v(" "),a("li",[n._v("算法就是操作数据的方法")]),n._v(" "),a("li",[n._v("数据结构和算法是相辅相成的, 数据结构是为算法服务的, 而算法要作用在特定的数据结构之上")])]),n._v(" "),a("p",[n._v("从广义上讲, 数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n从狭义上讲, 指某些著名的数据结构和算法, 比如队列、栈、堆、二分查找、动态规划等。\n数据结构和算法是相辅相成的。数据结构是为算法服务的, 算法要作用在特定的数据结构之上。")]),n._v(" "),a("ol",[a("li",[n._v("数据结构和算法学习的精髓-复杂度分析")]),n._v(" "),a("li",[n._v("最常用的、最基础的数据结构:数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树")]),n._v(" "),a("li",[n._v("最常用的算法:递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法")])]),n._v(" "),a("h2",{attrs:{id:"为什么学"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么学"}},[n._v("#")]),n._v(" 为什么学")]),n._v(" "),a("ol",[a("li",[n._v("直接好处是能够有写出性能更优的代码。")]),n._v(" "),a("li",[n._v("算法, 是一种解决问题的思路和方法, 有机会应用到生活和事业的其他方面。")]),n._v(" "),a("li",[n._v("长期来看, 大脑思考能力是个人最重要的核心竞争力, 而算法是为数不多的能够有效训练大脑思考能力的途径之一。")])]),n._v(" "),a("h2",{attrs:{id:"如何学"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何学"}},[n._v("#")]),n._v(" 如何学")]),n._v(" "),a("ol",[a("li",[n._v("一定要动手写")]),n._v(" "),a("li",[n._v("千万不要被动地记忆, 要多辩证地思考, 多问为什么。")]),n._v(" "),a("li",[n._v("边学边练, 适度刷题  多问、多思考、多互动")]),n._v(" "),a("li",[n._v("知识需要沉淀, 不要想试图一下子掌握所有")]),n._v(" "),a("li",[n._v("结合实际:排个队想到队列, 火车进站想到堆栈, 看到树上开花想到树的某些指标, 导航想到贪心, 将生活场景与算法和数据结构的场景结合起来。")])]),n._v(" "),a("h3",{attrs:{id:"重点学习"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重点学习"}},[n._v("#")]),n._v(" 重点学习")]),n._v(" "),a("p",[n._v("20 个最常用的、最基础数据结构与算法, 不管是应付面试还是工作需要, 只要集中精力逐一攻克这 20 个知识点就足够了。\n这里面有 10 个数据结构:数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树;\n10 个算法:递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。")]),n._v(" "),a("p",[a("strong",[n._v("复杂度分析")]),n._v("是整个算法学习的精髓, 只要掌握了它, 数据结构和算法的内容基本上就掌握了一半。")]),n._v(" "),a("h2",{attrs:{id:"复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复杂度"}},[n._v("#")]),n._v(" 复杂度")]),n._v(" "),a("p",[n._v("时间复杂度又称"),a("strong",[n._v("渐进时间复杂度")]),n._v(":表示算法的执行时间与数据规模之间的增长关系")]),n._v(" "),a("p",[n._v("空间复杂度全称就是渐进空间复杂度(asymptotic space complexity), 表示算法的"),a("strong",[n._v("存储空间与数据规模")]),n._v("之间的增长关系。")]),n._v(" "),a("h3",{attrs:{id:"时间复杂度-重中之中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度-重中之中"}},[n._v("#")]),n._v(" 时间复杂度(重中之中)")]),n._v(" "),a("p",[n._v("大 O 时间复杂度实际上并不具体表示代码真正的执行时间, 而是表示代码执行时间随数据规模增长的"),a("strong",[n._v("变化趋势")]),n._v(", 所以, 也叫作"),a("strong",[n._v("渐进时间复杂度")]),n._v("(asymptotic time complexity), 简称时间复杂度。")]),n._v(" "),a("p",[n._v("PS:即使一段代码循环 10000 次、100000 次, 只要是一个已知的数, 跟 n 无关, 照样也是常量级的执行时间。当 n 无限大的时候, 就可以忽略。")]),n._v(" "),a("p",[n._v("尽管对代码的执行时间会有很大影响, 但是回到时间复杂度的概念来说, 它表示的是一个算法执行效率与数据规模增长的变化趋势, 所以不管常量的执行时间多大, 我们都可以忽略掉。因为它本身对增长趋势并没有影响。")]),n._v(" "),a("h4",{attrs:{id:"方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[n._v("#")]),n._v(" 方法")]),n._v(" "),a("ol",[a("li",[n._v("只关注循环执行次数最多的一段代码")]),n._v(" "),a("li",[n._v("加法法则:总复杂度等于量级最大的那段代码的复杂度\n如果 T1(n)=O(f(n)), T2(n)=O(g(n));那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).")]),n._v(" "),a("li",[n._v("乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n如果 T1(n)=O(f(n)), T2(n)=O(g(n));那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).")])]),n._v(" "),a("h4",{attrs:{id:"常见的复杂度量级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的复杂度量级"}},[n._v("#")]),n._v(" 常见的复杂度量级")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126035226%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7.jpg",alt:"常见的复杂度量级"}}),n._v("\n我们可以粗略地分为两类, 多项式量级和非多项式量级。其中, 非多项式量级只有两个:O(2n) 和 O(n!)。")]),n._v(" "),a("p",[n._v("当数据规模 n 越来越大时, 非多项式量级算法的执行时间会急剧增加, 求解问题的执行时间会无限增长。所以, 非多项式时间复杂度的算法其实是非常低效的算法。")]),n._v(" "),a("p",[n._v("主要来看几种常见的多项式时间复杂度。")]),n._v(" "),a("h5",{attrs:{id:"o-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#o-1"}},[n._v("#")]),n._v(" O(1)")]),n._v(" "),a("p",[n._v("首先你必须明确一个概念, O(1) 只是常量级时间复杂度的一种表示方法, 并不是指只执行了一行代码。比如这段代码, 即便有 3 行, 它的时间复杂度也是 O(1), 而不是 O(3)。")]),n._v(" "),a("p",[n._v("一般情况下, 只要算法中不存在循环语句、递归语句, 即使有成千上万行的代码, 其时间复杂度也是Ο(1)。")]),n._v(" "),a("h5",{attrs:{id:"o-logn-、o-nlogn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#o-logn-、o-nlogn"}},[n._v("#")]),n._v(" O(logn)、O(nlogn)")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("i=1;\nwhile (i <= n)  {\n    i = i * 2;  可为2 3 4 时间复杂度就是 O(log2n) O(log3n)\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br")])]),a("p",[n._v("对数之间是可以互相转换的, log3n 就等于 log32 * log2n, 所以 O(log3n) = O(C *  log2n), 其中 C=log32 是一个常量。")]),n._v(" "),a("p",[n._v("基于我们前面的一个理论:在采用大 O 标记复杂度的时候, 可以忽略系数, 即 O(Cf(n)) = O(f(n))。")]),n._v(" "),a("p",[n._v("因此, 在对数阶时间复杂度的表示方法里, 我们忽略对数的“底”, 统一表示为 O(logn)。")]),n._v(" "),a("h5",{attrs:{id:"o-m-n-、o-m-n"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#o-m-n-、o-m-n"}},[n._v("#")]),n._v(" O(m+n)、O(m*n)")]),n._v(" "),a("p",[n._v("代码的复杂度由两个数据的规模来决定,从代码中可以看出, m 和 n 是表示两个数据规模。")]),n._v(" "),a("p",[n._v("我们无法事先评估 m 和 n 谁的量级大, 所以我们在表示复杂度的时候, 就不能简单地利用加法法则, 省略掉其中一个。所以, 上面代码的时间复杂度就是 O(m+n)。")]),n._v(" "),a("h3",{attrs:{id:"空间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[n._v("#")]),n._v(" 空间复杂度")]),n._v(" "),a("p",[n._v("全称就是渐进空间复杂度(asymptotic space complexity), 表示算法的"),a("strong",[n._v("存储空间与数据规模")]),n._v("之间的增长关系。")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("void print(int n) {\n  int i = 0;\n  int[] a = new int[n];\n  for (i; i <n; ++i) {\n    a[i] = i * i;\n  }\n\n  for (i = n-1; i >= 0; --i) {\n    print out a[i]\n  }\n}\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br")])]),a("p",[n._v("第 2 行代码中, 我们申请了一个空间存储变量 i, 但是它是常量阶的, 跟数据规模 n 没有关系, 所以我们可以忽略。")]),n._v(" "),a("p",[n._v("第 3 行申请了一个大小为 n 的 int 类型数组, 除此之外, 剩下的代码都没有占用更多的空间, 所以整段代码的空间复杂度就是 O(n)。")]),n._v(" "),a("p",[n._v("空间复杂度就是 O(1)、O(n)、O(n2), 像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。")]),n._v(" "),a("h3",{attrs:{id:"复杂度分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分类"}},[n._v("#")]),n._v(" 复杂度分类")]),n._v(" "),a("p",[n._v("四个复杂度分析方面的知识点")]),n._v(" "),a("ul",[a("li",[n._v("最好情况时间复杂度(best case time complexity)")]),n._v(" "),a("li",[n._v("最坏情况时间复杂度(worst case time complexity)")]),n._v(" "),a("li",[n._v("平均情况时间复杂度(average case time complexity)")]),n._v(" "),a("li",[n._v("均摊时间复杂度(amortized time complexity)")])]),n._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),a("p",[n._v("复杂度也叫渐进复杂度, 包括时间复杂度和空间复杂度, 用来分析算法执行效率与数据规模之间的增长关系, 可以粗略地表示,")]),n._v(" "),a("p",[n._v("越高阶复杂度的算法, 执行效率越低。常见的复杂度并不多, 从低阶到高阶有:O(1)、O(logn)、O(n)、O(nlogn)、O(n2)。")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126062213%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90.jpg",alt:"复杂度分析"}})]),n._v(" "),a("h2",{attrs:{id:"指针-引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#指针-引用"}},[n._v("#")]),n._v(" 指针 & 引用")]),n._v(" "),a("p",[n._v("有些语言有指针的概念, 如C;但有的语言没有指针, 取而代之的是引用, 如Java, Python。实际上意思是一样的, 都是存储所指对象的内存地址。")]),n._v(" "),a("p",[n._v("将某个变量赋值给指针, 实际上就是将该变量的地址赋值给该指针, 或者反过来说, 指针中存储了这个变量的内存地址, 指向了这个变量, 通过指针就能找到这个变量")]),n._v(" "),a("p",[n._v("为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？")]),n._v(" "),a("p",[n._v("其实, 我们不一定非要用栈来保存临时变量, 只不过如果这个函数调用符合后进先出的特性, 用栈这种数据结构来实现, 是最顺理成章的选择。")]),n._v(" "),a("p",[n._v("从调用函数进入被调用函数, 对于数据来说, 变化的是什么呢？是作用域。所以根本上, 只要能保证每进入一个新的函数, 都是一个新的作用域就可以。而要实现这个, 用栈就非常方便。在进入被调用函数的时候, 分配一段栈空间给这个函数的变量, 在函数结束的时候, 将栈顶复位, 正好回到调用函数的作用域内。")])])}),[],!1,null,null,null);t.default=v.exports}}]);