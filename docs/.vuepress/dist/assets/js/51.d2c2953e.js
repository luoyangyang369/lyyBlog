(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{551:function(t,a,e){"use strict";e.r(a);var v=e(6),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"关键字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关键字"}},[t._v("#")]),t._v(" 关键字")]),t._v(" "),e("h6",{attrs:{id:"string-intern"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#string-intern"}},[t._v("#")]),t._v(" String.intern()")]),t._v(" "),e("blockquote",[e("p",[t._v("从常量池中取到引用 没有的话则新建并返回")])]),t._v(" "),e("h6",{attrs:{id:"native"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#native"}},[t._v("#")]),t._v(" native")]),t._v(" "),e("blockquote",[e("p",[t._v("native是与C++联合开发的时候用的！使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。")])]),t._v(" "),e("h6",{attrs:{id:"volatile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[t._v("#")]),t._v(" volatile")]),t._v(" "),e("blockquote",[e("p",[t._v("内存可见性和禁止指令重排序\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。")])]),t._v(" "),e("p",[t._v("小结：")]),t._v(" "),e("ul",[e("li",[t._v("volatile 修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值。在并发包的源码中，它使用得非常多。")]),t._v(" "),e("li",[t._v("volatile 属性的读写操作都是无锁的，它不能替代 synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。")]),t._v(" "),e("li",[t._v("volatile 只能作用于属性，我们用 volatile 修饰属性，这样 compilers 就不会对这个属性做指令重排序。")]),t._v(" "),e("li",[t._v("volatile 提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile 属性不会被线程缓存，始终从主存中读取。")]),t._v(" "),e("li",[t._v("volatile 提供了 happens-before 保证，对 volatile 变量 v 的写入 happens-before 所有其他线程后续对 v 的读操作。")])]),t._v(" "),e("h6",{attrs:{id:"transient"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transient"}},[t._v("#")]),t._v(" transient")]),t._v(" "),e("p",[t._v("使用 transient 修饰，该关键字声明默认不会被序列化")]),t._v(" "),e("h6",{attrs:{id:"守护线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#守护线程"}},[t._v("#")]),t._v(" 守护线程")]),t._v(" "),e("p",[t._v("守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。")]),t._v(" "),e("p",[t._v("当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。")]),t._v(" "),e("p",[t._v("main() 属于非守护线程。")]),t._v(" "),e("h6",{attrs:{id:"线程-join"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程-join"}},[t._v("#")]),t._v(" 线程 .join()")]),t._v(" "),e("p",[t._v("就是插队： 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。")]),t._v(" "),e("h2",{attrs:{id:"常用用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用用法"}},[t._v("#")]),t._v(" 常用用法")]),t._v(" "),e("p",[t._v("List list = Arrays.asList(1, 2, 3);\nInteger[] arr = {1, 2, 3};")])])}),[],!1,null,null,null);a.default=r.exports}}]);