---
title: 架构 面经
date: 2021-05-29 17:25:25  # 建立日期
updated: 2021-05-29 17:25:25  # 更新日期
comments: true  # 开启文章的评论功能
tags: [面试]
index_img: /img/avatar.png
banner_img: /img/avatar.png  # 详情页图片
top: 9  # 设置权重,  主页那个先显示
copyright : ture  # 授权问题显示
categories: 面试
auto_spacing: true  # 在中文和英文之间加入空格
external_link: true  # 在新标签中打开链接
prev: network
# next: general3
---
<!-- [[toc]]  # 在页面显示目录 -->

[互联网 Java 工程师进阶知识完全扫盲](https://adjava.netlify.app/#/)
[一个面试题引起的SpringBoot启动解析](https://juejin.cn/post/6844903652201594887#heading-0)
[图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)
[消息队列面试题](https://blog.csdn.net/ThinkWon/article/details/104588612)

### 小知识

- Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。

### jdk 命令

- jstat: 查看 JVM 统计信息， 显示进程中的类装载、内存、垃圾回收等信息
- jinfo: 查看虚拟机配置参数信息， 也可用于调整虚拟机的配置参数。
- jmap: 导出内存映像文件&内存使用情况， 获取堆 dump 文件， 堆各区使用情况， 堆中对象的统计信息， 类加载信息等。
- jhat: 堆分析工具， 和 jmap 搭配使用， 启动一个HTTP服务， 网页查看信息。
- jstack： 线程快照， 可以查看到死锁、死循环等
- jcmd: 多功能命令行

### 有哪些方面的因素会导致网站访问慢？

1. 服务器出口带宽不够用
   - 本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。
   - 跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。
1. 服务器负载过大，导致响应不过来
   - 分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。
   - 如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。
3. 数据库瓶颈
   - 如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。
   - 如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。
4. 网站开发代码没有优化好
例如 SQL 语句没有优化，导致数据库读写相当耗时。

### cap、 base 理论

分布式系统的CAP理论：理论首先把分布式系统中的三个特性进行了如下归纳：
- **一致性（C）**：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
- **可用性（A）**：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）
- **分区容忍性（P）**：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

BASE理论： BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。
- **基本可用**： 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子
- **软状态**： 弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。
- **最终一致性**： 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性


### 秒杀场景设计

- 高并发&高性能
  - 热点数据处理
    - 静态热点数据 ：可以提前预测到的热点数据比如要秒杀的商品。
    - 动态热点数据 ： 不能够提前预测到的热点数据，需要通过一些手段动态检测系统运行情况产生。
    - 使用缓存， 那么会造成 `缓存雪崩，缓存击穿，缓存穿透` 问题
  - 流量削峰
    - 消息队列： 请求放到消息队列中去， 后端慢慢处理
    - 回答问题/验证码： 一方面可以避免用户请求过于集中，另一方面可以有效解决用户使用脚本作弊。
- 高可用
  - 集群化： 比如说 Nginx 集群、Kafka 集群、Redis 集群。
  - 限流： Hystrix 是 Netflix 开源的熔断降级组件。
  - 排队： 你可以把排队看作是限流的一个变种。限流是直接拒绝了用户的请求，而排队则是让用户等待一定的时间（类比现实世界的排队）。
  - 降级： 降级的核心思想就是丢车保帅，优先保证核心业务。

- 超卖
- 链接暴露： URL动态化， 通过MD5之类的加密算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。 
- 资源静态化： 那就把能提前放入cdn服务器的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。
- 按钮控制： 秒杀前，一般按钮都是置灰的，只有时间到了，才能点击。
- 限流： 限流这里我觉得应该分为前端限流和后端限流。
   - 前端限流：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。
   - 后端限流：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。
- 限流&降级&熔断&隔离： 这个为啥要做呢，不怕一万就怕万一，万一你真的顶不住了，限流，顶不住就挡一部分出去但是不能说不行，降级，降级了还是被打挂了，熔断，至少不要影响别的系统，隔离，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。

### SpringMVC 工作原理

1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。
3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。
4. `HandlerAdapter` 会根据 `Handler `来调用真正的处理器来处理请求，并处理相应的业务逻辑。
5. 处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
8. 把 `View` 返回给请求者（浏览器）

### 设计模式

- 创建性模式

设计模式名称 | 简要说明 | 速记关键字
:---:|:--|:---
工厂方法模式(Factory Method)  | 定义了创建对象的接口，它允许子类决定实例化哪个类 | 动态生产对象
抽象工厂模式(Abstract Factory) | 提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类 | 生产成系列对象
构建器模式(Builder) | 将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示 | 复杂对象构造
原型模式(Prototype) | 允许对象在不了解要创建对象的确切类以及如何创建等细节的情况下创建自定义对象。通过拷贝原型对象来创建新的对象 | 克隆对象
单例模式(Singleton) | 确保一个类只有一个实例，并且提供了对该类的全局访问入口 | 单实例

- 结构性模式

设计模式名称 | 简要说明 | 速记关键字
:---:|:--|:---
适配器模式(Adapter) | 将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作 | 转换接口
桥接模式(Bridge) | 将一个复杂的组件分成两个独立的但又相关的继承层次结构， 将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化 | 继承树拆分
组合模式(Composite) | 创建树型层次结构来改变复杂性，同时允许结构中的每一个元素操作同一个接口。用于表示“整体-部分”的层次结构 | 树形目录结构
装饰模式(Decorator) | 在不修改对象外观和功能的情况下添加或者删除对象功能， 即动态地给一个对象添加一些额外的职责 | 动态附加职责
外观模式(Facade) | 子系统中的一组接口提供了一个统一的接口 | 对外统一接口
享元模式(Flyweight) | 可以通过共享对象减少系统中低等级的、详细的对象数目， 提供支持大量细粒度对象共享的有效方法 | 汉字编码
代理模式(Proxy) | 为控制对初始对象的访问提供了一个代理或者占位符对象 | 快捷方式

- 行为性模式

设计模式名称 | 简要说明 | 速记关键字
:---:|:--|:---
职责链模式(Chain of Responsibility) | 可以在系统中建立一个链，这样消息可以在首先接收到它的级别处被处理，或者可以定位到可以处理它的对象 | 传递职责
命令模式(Command) | 在对象中封装了请求，这样就可以保存命令，将该命令传递给方法以及像任何其他对象一样返回该命令 | 日志记录，可撤销
解释器模式(Interpreter) | 可以解释定义其语法表示的语言，还提供了用表示来解释语言中的语句的解释器 | 虚拟机的机制
迭代器模式(Iterator) | 为集合中的有序访问提供了一致的方法，而该集合是独立于基础集合，并与之相分离的 | 数据集
中介者模式(Mediator) | 通过引入一个能够管理对象间消息分布的对象，简化了系统中对象间的通信 | 不直接引用
备忘录模式(Memento) | 保持对象状态的“快照”(snapshot)， 这样对象可以在不向外界公开其内容的情况下返回到它的最初状态 | 游戏存档
观察者模式(Observer) | 为组件向相关接收方广播消息提供了灵活的方法， 定义对象间的一种一对多的依赖关系 | 订阅、广播、联动
状态模式(State) | 允许一个对象在其内部状态改变时改变它的行为 | 状态变成类
策略模式(Strategy) | 定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化 | 多方案切换
模板方法模式(Template Method) | 提供了在不重写方法的前提下允许子类重载部分方法的方法 | 框架
访问者模式(Visitor) | 提供了一种方便的、可维护的方法来表示在对象结构元素上要进行的操作 | 数据与操作分离

### spring 设计模式有哪些

1. 简单工厂(非23种设计模式中的一种)： 
   - 实现方式： BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。
   - 实质： 由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。
2. 工厂方法
   - 实现方式： FactoryBean接口。
   - 实现原理： 实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。
3. 单例模式： 默认 bean
4. 适配器模式
    - 实现方式： SpringMVC中的适配器HandlerAdatper。
    - 实现原理： HandlerAdatper根据Handler规则执行不同的Handler。
    - 实现意义：HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。 因此Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。
5. 装饰器模式
   - 实现方式： Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。
   - 实质： 动态地给一个对象添加一些额外的职责。
6. 代理模式： AOP底层，就是动态代理模式的实现。
7. 观察者模式 又叫做发布-订阅
   - 实现方式： spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。
   - 具体实现： 事件机制的实现需要三个部分,事件源,事件,事件监听器

### 接口保证幂等性

1. 对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次，对吧。
2. 每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql 中记录个状态啥的，比如支付之前记录一条这个订单的支付流水。
3. 每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。

### 分布式服务接口请求的顺序性如何保证？

将任务放进队列里， 按照顺序处理， 具体就是一个队列对应一个消费者

### Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？

特性|	ActiveMQ|	RabbitMQ|	RocketMQ|	Kafka
:---:|:--:|:---:|:---:|:---:
单机吞吐量|	万级，比 RocketMQ、Kafka 低一个数量级|	同 ActiveMQ|	10 万级，支撑高吞吐	10 万级，高吞吐，一般配合大|数据类的系统来进行实时数据计算、日志采集等场景|
topic 数量对吞吐量的影响|||			topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic|	topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源
时效性|	ms 级|	微秒级，这是 RabbitMQ 的一大特点，延迟最低|	ms 级|	延迟在 ms 级以内
可用性|	高，基于主从架构实现高可用|	同 ActiveMQ|	非常高，分布式架构|	非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用
消息可靠性|	有较低的概率丢失数据|	基本不丢|	经过参数优化配置，可以做到 0 丢失|	同 RocketMQ
功能支持|	MQ 领域的功能极其完备|	基于 erlang 开发，并发能力很强，性能极好，延时很低|	MQ 功能较为完善，还是分布式的，扩展性好|	功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用

### 消息的顺序问题(发送有序)

消息有序指的是可以按照消息的发送顺序来消费。

解决：  保证生产者 - MQServer - 消费者是一对一对一的关系

### 消息的重复问题(去重表)

造成消息重复的根本原因是：网络不可达。

消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。

### 如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？

- 比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。
- 比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。
- 比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。
- 比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。

### 如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？

1. 生产者弄丢了数据: 
   -  RabbitMQ 提供的事务功能： 就是生产者发送数据之前开启 RabbitMQ 事务 channel.txSelect ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 channel.txRollback ，然后重试发送消息；如果收到了消息，那么可以提交事务 channel.txCommit 。
   - confirm 机制： 你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。
2. RabbitMQ 弄丢了数据
   - 开启 RabbitMQ 的持久化
3. 消费端弄丢了数据
   - 就是你必须关闭 RabbitMQ 的自动 ack ，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。

![rabbit消息丢失](/img/rabbit消息丢失.jpg)

### Mybatis #{}和${}的区别是什么？

```
#{}是预编译处理，${}是字符串替换。
Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的
set 方法来赋值；
Mybatis 在处理${}时，就是把${}替换成变量的值。
使用#{}可以有效的防止 SQL 注入，提高系统安全性。
```

### Spring Boot、Spring MVC 和 Spring 有什么区别？

- Spring 是一个“引擎”;
- Spring MVC 是基于Spring的一个 MVC 框架;
  - 它是Spring的一个模块，是一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。
- Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。
  - 实现了自动配置，降低了项目搭建的复杂度。它主要是为了解决使用Spring框架需要进行大量的配置太麻烦的问题

### @SpringBootApplication 注解

- @EnableAutoConfiguration：启用 SpringBoot 的自动配置机制
- @ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。
- @Configuration：允许在上下文中注册额外的 bean 或导入其他配置类

### 常用的注解有哪些？

```
Spring Bean 相关：

@Autowired : 自动导入对象到类中，被注入进的类同样要被 Spring 容器管理。
@RestController : @RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器 bean,并且是将函数的返回值直 接填入 HTTP 响应体中,是 REST 风格的控制器。
@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。
@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。
@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
@Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。
```

### Spring Bean生命周期

BeanFactory和ApplicationContext是Spring两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。

### 什么是 CAP 定理（CAP theorem）
在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：

- 一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）
- 可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）
- 分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。）
