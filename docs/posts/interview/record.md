---
title: 面试题记录
date: 2021-09-23 17:25:25  # 建立日期
updated: 2021-09-23 17:25:25  # 更新日期
comments: true  # 开启文章的评论功能
tags: [面试]
index_img: /img/avatar.png
banner_img: /img/avatar.png  # 详情页图片
top: 9  # 设置权重,  主页那个先显示
copyright : ture  # 授权问题显示
categories: 面试
auto_spacing: true  # 在中文和英文之间加入空格
external_link: true  # 在新标签中打开链接
# prev: general2
# next: general3
---

2021年十月遇到的面试题

<!-- more -->

### 泛型

泛型其实就是一种参数化的集合，它限制了你添加进集合的类型。泛型的本质就是一种参数化类型。多态也可以看作是泛型的机制。一个类继承了父类，那么就能通过它的父类找到对应的子类，但是不能通过其他类来找到具体要找的这个类。泛型的设计之处就是希望对象或方法具有最广泛的表达能力。

- 为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。
- 泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。
- 最显而易见的好处就是它不再需要对取出来的结果进行强制转换了。
- <?>被称作无限定的通配符； <? extends T>被称作有上限的通配符； <? super T>被称作有下限的通配符

### Java 中的类加载机制？

```
1. 加载： 通过类加载器加载
   1. 获取定义此类的二进制字节流
   2. 将这个字节流表示的一种存储结构转换为运行时数据区中方法区的数据结构。
   3. 在内存中生成一个 Class 对象，这个对象就代表了这个数据结构的访问入口。
2. 链接： 下面三个可能会交替执行
   1. 验证： 文件格式验证。 元数据验证。 字节码验证。 符号引用验证。
   2. 准备： 为类中的变量分配内存并设置其初始值的阶段，这些变量所使用的内存都应当在方法区中进行分配
   3. 解析： 是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。
3. 初始化：
  1. 执行类构造器方法 `<clinit>()` 的过程
  2. 此方法不需要定义，自动将所有类变量和静态代码块的语句合并起来
  3. `不同于类的构造器` 构造器是虚拟机视角下的 `<init>`
```

### 那锁的优化机制了解吗？

![重量锁的获取过程](/img/重量锁获取过程.webp)

从JDK1.6版本之后，synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。

锁的状态从低到高依次为无锁->偏向锁->轻量级锁->重量级锁，升级的过程就是从低到高，降级在一定条件也是有可能发生的。

- 自旋锁：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。

- 自适应锁：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。

- 锁消除：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。

- 锁粗化：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外。

- 偏向锁：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以用过设置-XX:+UseBiasedLocking开启偏向锁。

- 轻量级锁：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM将会使用CAS方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试自旋来获得锁。

整个锁升级的过程非常复杂，我尽力去除一些无用的环节，简单来描述整个升级的机制。

简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS了，而轻量级锁主要就是通过CAS修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。

### CAS( CompareAndSwap )

- 比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存中的值一致为止.
- CAS应用: CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
- 缺点： 
  - 循环时间长开销大： 自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。
  - 只能保证一个共享变量的操作： 只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。
  - ABA 问题， 通过版本号和时间戳。 Java 有 AtomicStampedReference 来解决

### @SpringBootApplication 注解

- @EnableAutoConfiguration：启用 SpringBoot 的自动配置机制
- @ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。
- @Configuration：允许在上下文中注册额外的 bean 或导入其他配置类

