---
title: 如何保证缓存与数据库的一致性
date: 2021-03-15 17:25:25  # 建立日期
updated: 2021-03-16 17:25:25  # 更新日期
comments: true  # 开启文章的评论功能
tags: [面试, 缓存]
index_img: /img/avatar.png
banner_img: /img/avatar.png  # 详情页图片
# top: 0  # 设置权重,  主页那个先显示
copyright : ture  # 授权问题显示
categories: 面试
auto_spacing: true  # 在中文和英文之间加入空格
external_link: true  # 在新标签中打开链接
# prev: general2
# next: general3
---
<!-- [[toc]]  # 在页面显示目录 -->

## 带着问题看答案

- 如何保证缓存与数据库的一致性 
- 更新的时候为什么是删除缓存，而不是更新缓存？ 
- 更新缓存 VS 淘汰缓存 
- 先操作数据库 vs 先操作缓存 
- 缓存架构的优化 
- 缓存架构的结论强调 
- 为什么缓存 和 数据库会不一致 
- 不一致的优化思路 

- 提问：任务队列已经做了任务队列串行化的工作，能否保证任务不并发执行？
- 提问：假设服务只部署一份，能否保证任我游不并发执行？ 
- 提问：假设1个服务只有一条数据库连接，能否保证任务不并发执行？ 
- 提问：假设服务只有1份，且只有1条数据库连接，能否保证任务不并发执行？

解决方案：让数据库的访问能 “串行化” 就行 多服务部署，上述方案就不可用 同一数据的访问落到同一个服务器上？ 
总结，改造连接池，解决数据不一致的问题 提问：取模是否会影响服务的可用性 提问：取模访问服务与取模访问DB,是否会影响各连接上的请求的负载均 衡？ 数据库主从不一致，怎么解？ 
提问：要是数据库的架构做了主从同步，读写分离 
提问：常见的数据库集群架构如何？ 为什么会出现不一致？ 如何避免这种主从延时导致的不一致？ 
总结：数据库主库和从库不一致，常见有这么几种优化方案： 比较经典的做法就是：缓存 + 数据库读写模式 


1. 查询的时候：先读缓存，缓存没有读数据库，然后取出数据库的数据，放入缓存， 返回响应。
2. 更新的时候：先更新数据库，然后在删除缓存。

## 更新的时候为什么是删除缓存，而不是更 新缓存？ 

一个比较耗时缓存计算场景，如果你频繁修改某个表的数据，每次都涉这个缓存更 新，但是这个缓存在这段时间内都不会被用到。 

例子：一个缓存涉及的表字段，在1分钟被修改20次，那么缓存也更新20次，但是这 个缓存在1分钟内，只有被读取到1次，有大量的冷数据。 

实际上，如果你删除了这个缓存的话，那么在1分钟内内，只有被读取这个缓存的时候 计算1次，并且写入缓存。开销大幅度降低，用到才去缓存，就是懒加载思想。

## 更新缓存 VS 淘汰缓存 

- **更新缓存**：数据不但写入数据库，还会写入缓存 
- **淘汰缓存**：数据只会写入数据库，不会写入缓存，只会把缓存删除掉 

**更新缓存的优点**： 缓存的命中率高，不会因为缓存没有去查询数据库 
**淘汰缓存的优点**：简单，直接删除缓存啊 

> 那么到底是更新缓存，还是淘汰缓存？ 

**取决于“更新缓存的复杂度”**，比如更新缓存的内容需要复杂查询计算，那么淘汰缓存 就更适合

## 先操作数据库 vs 先操作缓存 
当写操作发生时，假设淘汰缓存作为对缓存通用的处理方式，那么又面临着两种选择 

1. 先写数据库，再淘汰缓存 
2. 写淘汰缓存，再写数据库 怎么选择 

- **先淘汰缓存，再写数据库 ？**

对于一个不能保证事务性的操作时，一定涉及 “那个任务先做，那个任务后做” 的问 题，解决这个问题的方向是：

> 如果出现数据不一致，谁先做对业务的影响小，就先执行谁 
1. **假设先写数据库，再淘汰缓存**：第一步写数据库操作成功，第二步淘汰缓存失败， 则会出现 db 中是新数据，cache 中是旧数据，数据不一致了，**这是属于原子性被破坏，导致的不一致**
2. **假设先淘汰缓存，在写数据库**：第一步淘汰储存成功，第二部写数据库失败，则会 出现数据库中是旧的，缓存是空的，只会引起一次 Cache miss 【这就是所谓的数据 未命中“miss”】（就是缓存没有数据时候，重新查询数据库，写入缓存）

>> 结论：数据库和缓存的操作顺序，是很清楚的：先淘汰缓存，再写数据库。


