---
title: 数据结构与算法
date: 2019-6-11 17:25:25
tags: [数据结构]
index_img: /img/avatar.png
banner_img: /img/avatar.png  # 详情页图片
top: 9  # 设置权重, 主页那个先显示
copyright : ture  # 授权问题显示
categories: 算法
---

<!-- more -->

[总览图](https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126033120%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88%E5%9B%BE.jpg)
[wangzheng GitHub](https://github.com/wangzheng0822/algo/tree/master/python)
[各种排序演示图](https://visualgo.net/en)
[b站学习](https://www.bilibili.com/video/av685670)
## 是什么
1. 数据结构是指一组数据的存储结构
2. 算法就是操作数据的方法
3. 数据结构和算法是相辅相成的, 数据结构是为算法服务的, 而算法要作用在特定的数据结构之上

从广义上讲, 数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。
从狭义上讲, 指某些著名的数据结构和算法, 比如队列、栈、堆、二分查找、动态规划等。
数据结构和算法是相辅相成的。数据结构是为算法服务的, 算法要作用在特定的数据结构之上。

1. 数据结构和算法学习的精髓-复杂度分析
2. 最常用的、最基础的数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
3. 最常用的算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法
## 为什么学
1. 直接好处是能够有写出性能更优的代码。
2. 算法, 是一种解决问题的思路和方法, 有机会应用到生活和事业的其他方面。
3. 长期来看, 大脑思考能力是个人最重要的核心竞争力, 而算法是为数不多的能够有效训练大脑思考能力的途径之一。

## 如何学

1. 一定要动手写
2. 千万不要被动地记忆, 要多辩证地思考, 多问为什么。
3. 边学边练, 适度刷题  多问、多思考、多互动
4. 知识需要沉淀, 不要想试图一下子掌握所有
5. 结合实际：排个队想到队列, 火车进站想到堆栈, 看到树上开花想到树的某些指标, 导航想到贪心, 将生活场景与算法和数据结构的场景结合起来。

### 重点学习

20 个最常用的、最基础数据结构与算法, 不管是应付面试还是工作需要, 只要集中精力逐一攻克这 20 个知识点就足够了。
这里面有 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

**复杂度分析**是整个算法学习的精髓, 只要掌握了它, 数据结构和算法的内容基本上就掌握了一半。

## 复杂度

时间复杂度又称**渐进时间复杂度**：表示算法的执行时间与数据规模之间的增长关系

空间复杂度全称就是渐进空间复杂度(asymptotic space complexity), 表示算法的**存储空间与数据规模**之间的增长关系。


### 时间复杂度(重中之中)

大 O 时间复杂度实际上并不具体表示代码真正的执行时间, 而是表示代码执行时间随数据规模增长的**变化趋势**, 所以, 也叫作**渐进时间复杂度**(asymptotic time complexity), 简称时间复杂度。

PS：即使一段代码循环 10000 次、100000 次, 只要是一个已知的数, 跟 n 无关, 照样也是常量级的执行时间。当 n 无限大的时候, 就可以忽略。

尽管对代码的执行时间会有很大影响, 但是回到时间复杂度的概念来说, 它表示的是一个算法执行效率与数据规模增长的变化趋势, 所以不管常量的执行时间多大, 我们都可以忽略掉。因为它本身对增长趋势并没有影响。

#### 方法
1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
如果 T1(n)=O(f(n)), T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
如果 T1(n)=O(f(n)), T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).

#### 常见的复杂度量级
![常见的复杂度量级](https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126035226%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7.jpg)
我们可以粗略地分为两类, 多项式量级和非多项式量级。其中, 非多项式量级只有两个：O(2n) 和 O(n!)。

当数据规模 n 越来越大时, 非多项式量级算法的执行时间会急剧增加, 求解问题的执行时间会无限增长。所以, 非多项式时间复杂度的算法其实是非常低效的算法。

主要来看几种常见的多项式时间复杂度。

##### O(1)
首先你必须明确一个概念, O(1) 只是常量级时间复杂度的一种表示方法, 并不是指只执行了一行代码。比如这段代码, 即便有 3 行, 它的时间复杂度也是 O(1), 而不是 O(3)。

一般情况下, 只要算法中不存在循环语句、递归语句, 即使有成千上万行的代码, 其时间复杂度也是Ο(1)。

##### O(logn)、O(nlogn)
```
i=1;
while (i <= n)  {
    i = i * 2;  可为2 3 4 时间复杂度就是 O(log2n) O(log3n)
}
```
对数之间是可以互相转换的, log3n 就等于 log32 * log2n, 所以 O(log3n) = O(C *  log2n), 其中 C=log32 是一个常量。

基于我们前面的一个理论：在采用大 O 标记复杂度的时候, 可以忽略系数, 即 O(Cf(n)) = O(f(n))。

因此, 在对数阶时间复杂度的表示方法里, 我们忽略对数的“底”, 统一表示为 O(logn)。

##### O(m+n)、O(m*n)
代码的复杂度由两个数据的规模来决定,从代码中可以看出, m 和 n 是表示两个数据规模。

我们无法事先评估 m 和 n 谁的量级大, 所以我们在表示复杂度的时候, 就不能简单地利用加法法则, 省略掉其中一个。所以, 上面代码的时间复杂度就是 O(m+n)。

### 空间复杂度
全称就是渐进空间复杂度(asymptotic space complexity), 表示算法的**存储空间与数据规模**之间的增长关系。
```
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```
第 2 行代码中, 我们申请了一个空间存储变量 i, 但是它是常量阶的, 跟数据规模 n 没有关系, 所以我们可以忽略。

第 3 行申请了一个大小为 n 的 int 类型数组, 除此之外, 剩下的代码都没有占用更多的空间, 所以整段代码的空间复杂度就是 O(n)。

空间复杂度就是 O(1)、O(n)、O(n2), 像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

### 复杂度分类

四个复杂度分析方面的知识点
- 最好情况时间复杂度(best case time complexity)
- 最坏情况时间复杂度(worst case time complexity)
- 平均情况时间复杂度(average case time complexity)
- 均摊时间复杂度(amortized time complexity)

### 总结

复杂度也叫渐进复杂度, 包括时间复杂度和空间复杂度, 用来分析算法执行效率与数据规模之间的增长关系, 可以粗略地表示, 

越高阶复杂度的算法, 执行效率越低。常见的复杂度并不多, 从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)。

![复杂度分析](https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126062213%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90.jpg)

## 指针 & 引用

有些语言有指针的概念, 如C；但有的语言没有指针, 取而代之的是引用, 如Java, Python。实际上意思是一样的, 都是存储所指对象的内存地址。

将某个变量赋值给指针, 实际上就是将该变量的地址赋值给该指针, 或者反过来说, 指针中存储了这个变量的内存地址, 指向了这个变量, 通过指针就能找到这个变量


为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？

其实, 我们不一定非要用栈来保存临时变量, 只不过如果这个函数调用符合后进先出的特性, 用栈这种数据结构来实现, 是最顺理成章的选择。

从调用函数进入被调用函数, 对于数据来说, 变化的是什么呢？是作用域。所以根本上, 只要能保证每进入一个新的函数, 都是一个新的作用域就可以。而要实现这个, 用栈就非常方便。在进入被调用函数的时候, 分配一段栈空间给这个函数的变量, 在函数结束的时候, 将栈顶复位, 正好回到调用函数的作用域内。