---
title: Java 基础知识(一)
date: 2021-01-23 17:25:25  # 建立日期
updated: 2021-01-23 17:25:25  # 更新日期
comments: true  # 开启文章的评论功能
tags: [Java]
index_img: /img/avatar.png
banner_img: /img/avatar.png  # 详情页图片
top: 9  # 设置权重,  主页那个先显示
sticky: 2  # 文章置顶
copyright : ture  # 授权问题显示
categories: Java
auto_spacing: true  # 在中文和英文之间加入空格
external_link: true  # 在新标签中打开链接
# prev: ../java/learn
next: general2
---

Java 集合类、接口、抽象类介绍
<!-- [[toc]]  # 在页面显示目录 -->

## 参考资料

- [Java教程](http://c.biancheng.net/java/)
- [Java 到底是值传递还是引用传递？](https://www.zhihu.com/question/31203609)
- [《On Java 8》中文版](https://lingcoder.github.io/OnJava8/#/)
- [Java 编程思想](https://wizardforcel.gitbooks.io/thinking-in-java/content/)
- [Spring Boot 指南](https://snailclimb.gitee.io/springboot-guide/#/)
- [Java工程师进阶知识](https://adjava.netlify.app/#/)
- [标准版的API规范](http://jdk8_api.dev.jcstaff.club/)
- [可能是把Java内存区域讲的最清楚的一篇文章](https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md)
- [Java泛型详解](https://www.cnblogs.com/Blue-Keroro/p/8875898.html)
- [泛型面试题](https://cloud.tencent.com/developer/article/1033693)

#### Java 到底是值传递还是引用传递？

首先回顾一下在程序设计语言中有关将参数传递给方法(或函数)的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值, 而按引用调用(call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值, 而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言(不只是 Java)中方法参数传递方式。

Java 程序设计语言总是采用按值调用。也就是说, 方法得到的是所有参数值的一个拷贝, 也就是说, 方法不能修改传递给它的任何参数变量的内容。

java都是“值传递”即可,  关键看这个值是什么, 简单变量就是复制了具值, 引用变量就是复制了地址呗。字符串是不可变的

## 修饰符

![修饰符](/img/xiushifu.png)

关键字|用处|含义|备注
:---|:--:|:---:|:---:
void|方法前|函数无返回值|

## 规范

每个 java 源文件中允许有多个类。同时,  *源文件的名称必须要和其中一个类名相同*, , 否则编译器将会报错。每个独立的程序应该包含一个 `main()` 方法作为程序运行的入口。其方法签名和返回类型如下。代码示例:
```java
public static void main(String[] args) {
}
```

> 运行 Java 程序
```java
javac hello.java
java hello
```

## 语法

- equals() 的默认行为是比较对象的引用而非具体内容
- 布尔表达式 ? 值 1 : 值 2
若表达式计算为 true,  则返回结果 值 1 ;如果表达式的计算为 false, 则返回结果 值 2。

## 重写与重载

>> 重载就是同样的一个方法能够根据输入数据的不同, 做出不同的处理

>> 重写就是当子类继承自父类的相同方法, 输入数据一样, 但要做出有别于父类的响应时, 你就要覆盖父类方法

区别点	|重载方法	|重写方法
:--:|:--:|:--:
发生范围	|同一个类	|子类
参数列表	|必须修改	|一定不能修改
返回类型	|可修改	|子类方法返回值类型应比父类方法返回值类型更小或相等
异常	|可修改	|子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等;
访问修饰符	|可修改	|一定不能做更严格的限制(可以降低限制)
发生阶段	|编译期	|运行期

### 重写(Override)

方法的重写要遵循“两同两小一大”

- “两同”即方法名相同、形参列表相同;
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等, 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等;
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

⭐️ 关于 重写的返回值类型 这里需要额外多说明一下, 上面的表述不太清晰准确:如果方法的返回类型是void和基本数据类型, 则返回值重写时不可修改。但是如果方法的返回值是引用类型, 重写时是可以返回该引用类型的子类的。

使用 `@Override` 注解, 可以让编译器帮忙检查是否满足上面的三个限制条件。

### 重载

方法的重载( overload )是指一个类中可以定义多 个方法名相同,但参数不同的方法。调用时 ,会根据不同的参数自动匹配对应的方法。

> 重载规则:
- 被重载的方法必须改变参数列表(参数个数或类型不- -样) ;
- 被重载的方法可以改变返回类型;
- 被重载的方法可以改变访问修饰符;
- 被重载的方法可以声明新的或更广的检查异常;
- 方法能够在同一个类中或者在一个子类中被重载;
- 无法以返回值类型作为重载函数的区分标准;

## 类与对象

### 构造函数的概念与特点
在类的对象创建时定义初始化的状态,和类名称相同的无返回值函数
> 特点:
- 对象方法不能调用构造方法
- 构造函数的函数名要与类名-样:类名(形参类型形参){}
- 构造函数在实例化的时候就会被调用, 实例化一次调用一 次
- 构造函数调用必须是构造函数中的第一个语句
注意:在构造函数中可以调用本类的其他重载构造函数,不能使用构造函数名称来调用另一个构造函
数,而是使用hi...)来调用
- 构造函数可以被重载, 但不能重写
- 构造函数用于初始化参数
- 构造函数没有返回值,因此也没有类型,作用只是对对象进行初始化

## 继承

### 继承的概念
- 通过继承可以使得子类访问父类的非私有成员变量以及成员方法(但不能选择性地继承
父类) ,可以增加新的数据或新的功能,还可以对父类中原有的方法进行覆盖重写;这
样可以增强代码的复用性,提高了代码的可维护性
- java中继承只能单父类继承
- extends 表示继承

### 构造函数的继承与执行顺序
- 如果一个类没有任何显式创建的构造器则该类默认会有一个无参构造器;如果显式创建了有参构
造器则该类就不再有默认无参构造器
- 在Java继承中,构造器并不能被继承,而是被显式或隐式调用。
- 子类的构造方法中必须调用其基类的构造方法(显式或隐式)

1、 若在子类构造方法中没有显式调用,系统在子类构造方法开始自动隐式调用父类的无参数构造方法
super()。因此若此时父类中没有无参数构造器则会编译出错

2、 若是显式调用,则可以通过super(argument_ list) 来调用,且super调用必须在首行以保证子类对象从
所有直接或间接父类中继承的实例变量都被正确地初始化( this关键字可以调用本类中的其他构造器,也必
须在首句, 因此this和super没法同时用)

> 父类静态代码块-->子类静态代码块--> 父类构造函数-->子类构造函数

### 子类重写父类的方法
有时父类提供的方法会出现在子类中不适用的情况,此时就可以通过重写父类的方法来解决问题

>> 注意事项
- 父类中的方法在子类中必须可见,即子类继承了父类中的该方法(可以显式的使用super关键字
来访问父类中的被重写的方法) , 如果父类中的方法为private类型的,那么子类虽能继承,但
无法覆盖
- 子类和父类的方法必须是实例方法,如果父类是static方法而子类是实例方法,或者相反都会报, 
错。如果父类和子类都是static 方法,那么子类隐藏父类的方法,而不是重写父类方法
- 子类和父类的方法必须要具有相同的函数名称、参数列表,并且子类方法的返回值与父类相同或
者是父类返回类型的子类型
- 子类方法的访问权限应该等于或大于父类方法的访问权限(可以具有相同的访问权限或者子类的
访问权限大于父类)。访问权限由高到低: public、protected、 包访问权限、private。 如果子
类方法的访问权限低于父类,则编译器会给出错误信息
- 子类方法不能比父类方法抛出更多的编译时异常(不是运行时异常) ,即子类方法抛出的编译时
异常或者和父类相同或者是父类异常的子类。当然,子类也可以不抛出异常,或者抛出
RuntimeException异常

## 组合和继承

- “组合”(Composition)

已经被多次使用。你仅需要把对象的引用(object references)放置在一个新的类里, 这就使用了组合。

- “继承”(Inheritance)
采用现有类形式, 又无需在编码时改动其代码

## interface(接口)

### 接口定义
接口就是一个规范和抽象类比较相似。它只管做什么,不管怎么做。通俗的讲,接口就是某个事物对外提供的一
些功能的声明,其定义和类比较相似,只不过是通过interface关键字来完成
### 知识点
- 接口中的所有属性默认为: public static final *** (属性不能够被更改) ;
- 接口中的所有方法默认为: public abstract **** (方法默认为抽象方法,实现类必须去重写接口中的方法) ;
- 接口不再像类-样用关键字extends去“继承”, 而是用implements去“实现”, 也就是说类和接口的关系
叫做实现

### 接口实现的注意点

- 实现一个接口就是要实现该接口的所有的方法(抽象类除外)。
- 接口中的方法都是抽象的。
- 多个无关的类可以实现同一个接口, 一个类可以实现多个无关的接口。

### extends与implements的区别

extends 是继承父类, 只要那个类不是声明为final或者那个类定义为abstract的就能继承, JAVA中不支持多重继承, 但是可以用接口来实现, 这样就用到了implements, 继承只能继承一个类, 但implements可以实现多个接口, 用逗号分开就行了。

## 抽象类
### 抽象类定义
- abstract修饰的类为抽象类,此类不能有对象, (无法对此类进行实例化,说白了就是不能new)
- abstract修饰的方法为抽象方法,此方法不能有方法体
### 知识点
- 抽象类不能有对象,不能用new此关键字来创建抽象类的对象;
- 有抽象方法的类一定是抽象类,但是抽象类中不一定有抽象方法 ;
- 抽象类中的抽象方法必须在子类中被重写。

## 接口与抽象类对比

类型 |abstract class|interface
:--:|:--:|:--:
定义|关键字abstract 修饰的类|关键字interface修饰
继承|抽象类可以继承一个类和实现多个接口(单继承, 多实现), 子类只可以继承一个抽象类|接口只可以继承接口(-个或者多个) ;子类可以实现多个接口
访问修饰符|抽象类可以有public. protected 和default 这些修饰符(要保证子类可以继承父类)|接口只能是public (要保证类的实现)
方法实现|可以定义构造方法, 可以有抽象方法和具体方法|接口是抽象的, 没有构造方法, 且方法都默认是抽象方法, 但在jdk1.8,接口中的方法可以具体实现, 用default关键字。
实现方法|子类使用extends关键字来继承抽象类。如果子类不是抽象类的话, 它需要提供抽象类中所有声明的方法的实现|子类使用implements来实现接口, 子类需要提供接口中所有声明的方法的实现
作用|把相同的东西提取出来, 即重用|把程序模块进行固化的契约, 降低耦合
