---
title: 垃圾回收
date: 2021-03-15 17:25:25  # 建立日期
updated: 2021-03-16 17:25:25  # 更新日期
comments: true  # 开启文章的评论功能
tags: [Java]
index_img: /img/avatar.png
banner_img: /img/avatar.png  # 详情页图片
top: 9  # 设置权重,  主页那个先显示
copyright : ture  # 授权问题显示
categories: Java
auto_spacing: true  # 在中文和英文之间加入空格
external_link: true  # 在新标签中打开链接
prev: jvm
# next: general3
---
<!-- [[toc]]  # 在页面显示目录 -->

## 垃圾回收相关概念

### System.gc()

- 在默认情况下，通过System. gls ()或者Runtime . getRuntime() .gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。
- 然而System. gc()调用附带-一个免责声明，无法保证对垃圾收集器的调用。 
- JVM实现者可以通过System. gc ()调用来决定JVM的GC行为。而- -般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()。

### 内存溢出与内存泄漏

- 内存溢出(OOM)： javadoc 中对 OutOfMemoryError 的解释是， 没有空闲内存，并且垃圾收集器也无法提供更多内存。
    1. Java 虚拟机设置的堆内存不够
    2. 代码中创建了大量大对象， 并且长时间不能被 GC
    3. 一般在 OOM 之前， JVM 都会尝试 GC(当分配一个超大对象， 分配超过了堆最大值， 则不会触发 GC， 因为GC 了也没用)， 还是没有空间则会报错
- 内存泄漏(Memory Leak)： 严格来说， 只有对象不被用到， 但是GC 又不能回收他们。 宽泛来讲， 导致对象的生命周期变的很长甚至 OOM 。

#### 举例

1. 单例模式： 单例的生命周期和应用程序一样长， 如果单例程序中持有外部对象引用， 则这个外部对象则不会被回收
2. 一些需要 close 的资源未关闭。 如： 数据库连接、网络连接、 IO。

### STW(Stop The World)

Stop- the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。

- 可达性分析算法中枚举根节点(GC Roots) 会导致所有Java执行线程停顿。
  - 分析工作必须在一个能确保一致性的快照中进行
  - 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
  - `**如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证**`

### 垃圾回收的并行和并发

> 垃圾回收的并行和并发与操作系统的并行并发不一样

- 并行(Parallel): 指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
  - 如 ParNew、 Parallel Scavenge、 Parallel 0ld;
- 串行(Serial)
  - 相较于并行的概念，单线程执行。
  - 如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。
- 并发(Concurrent): 指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行。
  - 用户程序在继续运行，而垃圾收集程序线程运行于另- -个CPU.上;
  - 如: CMS、G1

### 安全点(Safepoint)

程序执行时并非在所有地方都能停顿下来开始GC， 只有在特定的位置才能停顿下来开始GC,这些位置称为“安全点(Safepoint)”。

Safe Point的选择很重要，**如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题**。大部分指令的执行时间都非常短暂， 通常会根据**“是否具有让程序长时间执行的特征”**为标准。比如:选择些执行时间较长的指令作为Safe Point， 如方法调用、循环跳转和异常跳转等。

安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region 看做是被扩展了的 Safepoint。

### 引用-强软弱虚

Reference 子类中只有终结器引用是包内可见的，其他3种引用类型均为public, 可以在应用程序中直接使用

> 以下四种引用强度从上到下依次减弱

- 强引用(Strong Reference) - 不回收
  - 最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object( )”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用(Soft Reference) - 内存不足即回收
  - 在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
  - 用于高速缓存
- 弱引用(Weak Reference) - 发现即回收
  - 被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
  - 可有可无的缓存数据
- 虛引用(Phantom Reference) - 对象回收跟踪
  - 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
  - 跟踪垃圾回收过程

## 垃圾回收相关算法

判断对象存活的一般方式：
- 引用计数： Java 回收器没有使用
  - 优点： 实现简单， 便于识别垃圾， 回收没有延迟
  - 缺点： 1、 需要单独的计数器， 存储空间和时间的开销 2、 处理不了循环引用
- 可达性分析算法(标记算法)： 以根对象为起始点， 从上至下搜索所链接的目标对象是否可达

> Python 如何解决循环引用的问题？ 1、 手动解除 2、 使用弱引用 weakref 库

### GC Roots

> 类变量、局部变量

- 虚拟机栈中引用的对象
    - 比如:各个线程被调用的方法中使用到的参数、局部变量等。
- 本地方法栈内JNI (通常说的本地方法)引用的对象
- 方法区中类静态属性引用的对象
    - 比如:Java类的引用类型静态变量
- 方法区中常量引用的对象
    - 比如:字符串常量池(String Table)里的引用
- 所有被同步锁synchroni zed持有的对象
- Java虚拟机内部的引用。
    - 基本数据类型对应的Class对象，一些常驻的异常对象(如: NullPointerException、OutOfMemoryError)，系统类加载器。
- 反映java虛拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

> 小技巧: 由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。

### 对象的 finalization 机制

> finalization 机制 相当于有一次复活的机会

- 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点:
    - 在finalize() 时可能会导致对象复活。
    - finalize() 方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize ()方法将没有执行机会。
    - 一个糟糕的finalize()会严重影响GC的性能。
- 从功能上来说，finalize () 方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以 finalize ()方法在本质上不同于C++中析构函数。
- 由于finalize ()方法的存在，**虚拟机中的对象一般处于三种可能的状态**。

定义虚拟机的对象可能有三种状态：

1. 可触及的:从根节点开始，可以到达这个对象。
2. 可复活的:对象的所有引用都被释放，但是对象有可能在finalize()中复活。
3. 不可触及的:对象的finalize() 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。

以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。

### 回收算法

- 标记-清除算法(Mark-Sweep)
  - 这里的清除不会真正的清除， 而是把需要清除的对象地址保存在列表中， 下次加载新对象， 直接覆盖
  - 优点： 实现简单
  - 缺点
      1. 效率不算高。 需要遍历俩次(一次遍历可达对象， 一次遍历全部对象把不可达放到列表)
      2. GC 的时候需要 STW， 用户体验差
      3. 会产生内存碎片， 需要维护空闲列表以便于新对象内存的分配(区别于指针碰撞-空闲内存连续如复制算法)
- 复制算法(Copying)
  - 优点： 
    - 没有标记的过程(直接将存活的对象复制到 to 区)实现简单， 运行高效
    - 没有碎片问题， 可以直接使用指针碰撞分配内存
  - 缺点
    - 需要俩倍的内存空间
    - 复制到另一片内存空间后， 需要重新维护对象之间的引用关系(比如 栈中的变量的地址指向需要变)
  - > 特别注意： 复制算法需要存活数量不太大， 不然清理的垃圾少， 但是花费了复制的时间。 所以适用于垃圾很多的 Young 区
- 标记-压缩(整理、Mark-Compact)算法
  - 优点： 解决了上面俩个的缺点。 没有碎片、 内存也不会减半
  - 缺点： 
    - 效率最低 低于清除和复制
    - 需要重新维护对象之间的引用关系(和复制一样)

#### 总结

| |  Mark-Swecp   | Mark-Compact  | Copying
|  :----:  | :----:  | :----:  | :----:  |
| 速度  | 中等 | 最慢  | 最快  |
| 空间开销  | 少(但会堆积碎片) | 少(但会堆积碎片)  | 通常需要活对象的2倍大小(不堆积碎片)  |
| 移动对象  | 否 | 是  | 是  |

#### 分代收集算法

> 总和上面的几种算法， 具体问题具体分析。 几乎所有的 GC 都是用分代收集。

- 年轻代(Young Gen)
  - 特点： 区域较老年代小， 对象生命周期短， 存活率低， 回收频繁
  - 所以使用复制算法， 速度最快
- 老年代(Tenured Gen)
  - 特点： 区域大， 对象生命周期长， 存活率高， 回收不频繁
  - 一般使用标记-清除、 标记、整理

#### 分区算法

一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 Gc 产生的停顿也越长。为了更好地控制 Gc 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。

## 垃圾回收器

### GC 分类和性能指标

部分收集() & 整堆收集(FUll GC)

年轻代 GC： young GC == Minor GC
老年代 GC： major GC
Full GC： 全部回收一遍

- 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。
- 串行回收 & 并行回收
  - 串行回收： 指同一时间段内只允许有一个 CPU 用于执行垃圾回收， 此时工作线程暂停， 直至垃圾收集工作结束。
    - 在单 CPU 或较小应用内存， 适合串行回收器， 它默认被用于 Client 模式下的 JVM
    - 并发能力比较强的 CPU 上， 并行回收器产生的停顿时间短与串行回收器。
  - 并行回收： 同时运用多个 CPU 执行垃圾回收， 提升应用吞吐量。
- 按照工作模式分为 并发式和独占式
  - 并发式垃圾回收器与应用程序线程交替工作， 以尽可能减少应用程序的停顿时间
  - 独占式垃圾回收器， 一旦运行， 就会 STW， 停止用户线程

#### 评估 GC 的性能指标

- `吞吐量:运行用户代码的时间占总运行时间的比例`
  - (总运行时间:程序的运行时间十内存回收的时间)
- 垃圾收集开销:吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
- `暂停时间:执行垃圾收集时，程序的工作线程被暂停的时间。`
- 收集频率:相对于应用程序的执行，收集操作发生的频率。
- 内存占用: Java堆区所占的内存大小。
- 快速:一个对象从诞生到被回收所经历的时间。

> 吞吐量和暂停时间是最重要的， 也是一对相悖的参数
> 提升吞吐量就是要用户线程多执行， `降低内存回收频率(少 GC)`， 那相应的就要减少 GC， 那每次的 GC 暂停时间就长， 反之为了降低每次回收的暂停时间， `也就只能频繁的执行内存回收`， 就会引起吞吐量的下降。  这里有个前提就是， 一次 GC 肯定比多次 GC 同样的垃圾时间短。

### 7 款经典的垃圾回收器

串行回收器: Serial、 Serial Old
并行回收器: ParNew、 Parallel Scavenge、 Parallel Old
并发回收器: CMS、 G1

![垃圾回收器](/img/lj_hsq.jpg)

1. 两个收集器间有连线，表明它们可以搭配使用:
Serial/Serial Old、Serial/CMS、ParNew/Serial Old、 ParNew/CMS、 Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;
2. 其中Serial Old 作为 CMS 出现 "Concurrent Mode Failure" 失败的后备预案。
3. (红色虚线) 由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、 ParNew+Serial Old 这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了这些组合的支持(JEP214)，即: 移除。
4. (绿色虚线) JDK 14中: 弃用Parallel Scavenge 和Serial Old GC组合(JEP366)
5. (青色虚线) JDK 14中: 删除CMS垃圾回收器 (JEP 363)

#### Serial 回收器： 串行回收

年轻代 - Serial 老年代 - Serial Old

- Serial 作为 HotSpot 中 Client 模式下的默认新生代垃圾回收器
- Serial 采用复制算法、 串行回收和 STW 机制执行回收
- Serial Old 同样采用串行和 STW， 算法使用 标记-压缩
- 优势： 简单高效， 单 CPU 来说、 运行在 Client 模式下不错的选择

#### ParNew 回收器： 并行回收

年轻代 - ParNew 老年代 - Serial Old/CMS

> ParNew 除了采用 `并行回收` 的方式外， 与 Serial 几乎没有区别。

#### Parallel Scavenge 回收器： 吞吐量优先

年轻代 - Parallel 老年代 - Parallel Old

Parallel Scavenge 回收器也采用了 `复制算法、并行回收和 STW 机制`
与 ParNew 的区别：
1. 达到一个可控制的吞吐量， 吞吐量优先
2. 自适应调节策略(年轻代大小、 Eden和Survivor的比例、晋升老年代的年龄等参数自动调节)

Parallel Old 回收器采用了 标记-压缩算法， 但同样是基于并行回收和 STW 机制

> Parallel & Parallel Old 回收器 是 Java8 的默认回收器

#### CMS(Concurrent Mark Sweep) 回收器： 低延迟

年轻代 - Serial/ParNew 老年代 - CMS

> 第一款真正意义上的并发收集器， 第一次实现垃圾收集线程和用户线程同时工作

CMS 采用 `标记-清除` 算法， 也会 STW。

![cms收集器](/img/cms.jpg)

- 工作原理： 初始标记 - 并发标记 - 重新标记 - 并发清理
1. 初始标记(Initial-Mark)阶段: 在这个阶段中，程序中所有的工作线程都将会因为 “Stop-the-World” 机制而出现短暂的暂停，这个阶段的主要任务仅`仅只是标记出 GCRoots 能直接关联到的对象`。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的`速度非常快`。
2. 并发标记(Concurrent-Mark) 阶段: 从GC Roots 的`直接关联对象开始遍历整个对象图的过程`，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起`并发运行`。
3. 重新标记(Remark) 阶段: 由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了`修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录`，这个阶段的停顿时间通常会比初始标记阶段稍长--些，但也远比并发标记阶段的时间短。
4. 并发清除(Concurrent - Sweep)阶段: 此阶段`清理删除掉标记阶段判断的已经死亡的对象`，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

#### 注意事项

- 由于垃圾回收阶段用户线程没有中断， 所以在 CMS 回收过程中， `还应该确保用户线程有足够内存可用`， 所以不能和其他收集器一样等到老年代快满了收集， 而是`当堆空间达到一定阈值便开始回收`。 如果 CMS 期间内存不够用户线程运行， 则虚拟机临时启动 Serial Old 重新收集老年代。
- 采用标记-清除， 会产生内存碎片， 所以分配新对象只能选择空闲列表执行分配
- 为什么不采用 标记-复制，因为 CMS 期间用户线程还在运行， 修改内存肯定是不行的。

#### 优缺点

- 优点
  - 并发收集
  - 低延迟
- 缺点
  - 产生内存碎片
  - 对 CPU 资源敏感， 并发阶段， 虽然不会导致用户停顿， 但会因为占用一部分线程而导致应用程序变慢， 吞吐量降低
  - 无法处理浮动垃圾(并发标记阶段产生的新垃圾对象， CMS 无法处理， 只能等到下次 GC)

### 回收器小结

如果你想要最小化地使用内存和并行开销，请选 Serial GC; (串行执行)
如果你想要最大化应用程序的吞吐量，请选 Parallel GC; (并行执行)
如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。 (并发执行-并发标记、并发清理阶段)

### G1 回收器： 区域分代化、垃圾优先

- 并行收集器， 它把堆内存分为很多个区域(Region 物理上并不连续)。 不同的 Region 表示 Eden、 幸存者0、1区、老年区
- 跟踪收集每个 Region 的收集价值(回收的空间以及回收所需的时间)， 维护一个优先列表， `每次根据允许的收集时间， 优先回收价值最大的 Region`。
- `针对多核CPU及大量内存， 极高概率满足 GC 停顿时间的同时， 兼顾高吞吐量`

#### 回收过程 Remembered Set

避免全局扫描， 每个 Region 都有一个对应的 Remembered Set 记录当前 Region 中的对象被其他任意 Region 引用。

#### 优势
- 并行与并发
  - 并行： 多个 GC 线程同时执行， 此时用户线程 STW
  - 并发： 部分工作可以和应用程序同时执行
- 分代回收
  - 依然属于分代型回收器， 还是会区分年轻代和老年代， 但是空间不一定连续且不固定(每次回收完可能会变)
  - 兼顾年轻代和老年代， 对比其他收集器， 同时应用
- 空间整合
  - CMS： 标记-清除算法、 内存碎片、 若干次 GC 后进行一次碎片整理
  - G1 回收是以 Region 为基本单位。 Region 之前是复制算法， 但整体是标记-压缩算法。 当Java 堆非常大的时候，优势更加明显。
- 指定垃圾回收不得超过 N 毫秒
  - 由于分区， 缩小了回收的范围， 对于全局停顿的发生得到较好控制。
  - 根据优先队列， 每次在允许时间内回收价值最大的 Region， 尽可能的提高了效率。

#### 缺点

- 还不具备对于 CMS 压倒性的优势， 为了垃圾回收产生的内存占用及运行额外执行负载都比 CMS 高。
- 小内存应用上 CMS 优于 G1， 大内存则发挥其优势， 平衡点在 6-8 G。

### 七种经典垃圾回收器总结

![七种经典垃圾回收器](/img/seven_lj.jpg)

GC 发展阶段：

Serial(串行) => Parallel(并行) => CMS(并发) => G1 => ZGC

### 测试堆空间常用的jvm参数

```
-Xx: +PrintFlagsInitial : 查看所有的参数的默认初始值I
-xXX: +PrintFlagsFinal : 查看所有的参数的最终值(可能会存在修改，不再是初始值)
-Xms: 初始堆空间内存 (默认为物理内存的1/64)
-Xmx: 最大堆空间内存(默认为物理内存的1/4)
-Xmn: 设置新生代的大小。(初始值及最大值)
-XX: NewRatio: 配置新生代与老年代在堆结构的占比
-XX: SurvivorRatio: 设置新生代中Eden和s0/S1空间的比例
-XX: MaxTenuringThreshold: 设置新生代垃圾的最大年龄
-XX: +PrintGCDetails: 输出详细的GC处理日志
打印gc简要信息:
  1. -XX:+PrintGC
  2. -verbose:gc
-XX:HandlePromotionFailure: 是否设置空间分配担保

-xx:+PrintCommandLineFlags: 查看命令行相关参数(包含
使用的垃圾收集器)
使用命令行指令: jinfo - -flag相关垃圾回收器参数进程ID
```
