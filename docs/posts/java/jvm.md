---
title: JVM 内存
date: 2021-04-13 17:25:25  # 建立日期
updated: 2021-04-13 17:25:25  # 更新日期
comments: true  # 开启文章的评论功能
tags: [Java]
index_img: /img/avatar.png
banner_img: /img/avatar.png  # 详情页图片
top: 9  # 设置权重,  主页那个先显示
copyright : ture  # 授权问题显示
categories: Java
auto_spacing: true  # 在中文和英文之间加入空格
external_link: true  # 在新标签中打开链接
# prev: general2
next: jvm2
---
<!-- [[toc]]  # 在页面显示目录 -->

## JVM 分类

除了 Sun Classic VM(只有解释器，所以效率慢) 外，其他 JVM 都包含解释器和 JIT 编译器(**后端编译**，字节码编译为机器码)
> ps: 前端编译器-编译为字节码  后端编译器-字节码编译为机器码

其他 JVM 会将经常执行的代码(热点代码)编译为机器码并缓存起来

>> 以下 JVM 没有特指即为 hotspot

![JVM](/img/jvm.jpg)

# 类加载子系统

- ClassLoader 只负责类的加载，是否能运行则由执行引起决定
- 加载的类信息会放在方法区，除了类信息还有常量池信息

## 类加载器

.class => JVM => 元数据模板， 这个过程就需要一个运输工具(类加载器)

Java虚拟机的启动是通过引导类加载器(bootstrap class loader) 创建一个初始类(initial class) 来完成的，这个类是由虚拟机的具体实现指定的。

### 分类
1. 启动类加载器(引导类加载器)
  - C++编写，负责Java核心库，无法获取(打印出来是 null)
  - 加载 Java 的核心库 rt、java、javax
2. 扩展类加载器
  - 派生于 ClassLoader 父类为 启动类加载器 
  - 加载 jre/lib/ext 子目录
3. 应用程序类加载器(系统类加载器)
  - 是程序的默认加载器
> 从上往下的顺序尝试加载类，从下往上的顺序判断类是否加载

### 双亲委派模式
> 对 class 文件是按需加载
1. 如果一个类加载器接收到了类加载的请求，它自己不会先去加载，会把这个请求委托给父类加载器去执行。
2. 如果父类还存在父类加载器，则继续向上委托，一直委托到启动类加载器：Bootstrap ClassLoader
3. 如果父类加载器可以完成加载任务，就返回成功结果，如果父类加载失败，就由子类自己去尝试加载，如果子类加载失败就会抛出ClassNotFoundException异常，这就是双亲委派模式

- 优点：
  - 避免类的重复加载
  - 防止核心 API 被篡改

## 类的加载过程

1. 加载
   - 获取类的二进制流
   - 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
   - 在内存中生成代表这个类的 java.lang.class 对象，作为访问入口
2. 链接
   - 验证： 四种验证 文件格式、元数据、字节码、符号引用
   - 准备： 
       - 类变量分配内存并且设置默认值
       - 不包含 final 引用的
       - 不会为实例变量分配初始化，类变量
   - 解析： 将常量池内的符号引用转化为直接引用
3. 初始化
   - 执行类构造器方法 `<clinit>()` 的过程
   - 此方法不需要定义，自动将所有类变量和静态代码块的语句合并起来
   - `不同于类的构造器` 构造器是虚拟机视角下的 `<init>`

# JVM 内存区域(运行时数据区)

- 方法区(hotspot特有)
类加载的信息就放在这里，除了类信息，还有运行时的常量池、字符串字面量、数字常量

- 虚拟机栈

描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建栈桢，主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机很明确，所以这块区域不需要进行 GC。

- 本地方法栈

与虚拟机栈功能非常类似，主要区别在于虚拟机栈为虚拟机执行 Java 方法时服务，而本地方法栈为虚拟机执行本地方法时服务的。这块区域也不需要进行 GC

- 程序计数器

> 当前线程的执行位置  比如: 21   即执行到字节码的第 21 行

线程独有的， 可以把它看作是当前线程执行的字节码的行号指示器，在每个字节码`前面都有一个数字（行号），我们可以认为它就是程序计数器存储的内容

> 作用： 线程切换的时候，记录下之前线程执行的代码行号

- 本地内存

线程共享区域，Java 8 中，本地内存，也是我们通常说的堆外内存，包含元空间和直接内存,注意到上图中 Java 8 和 Java 8 之前的 JVM 内存区域的区别了吗，在 Java 8 之前有个永久代的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，主要存储类的信息，常量，静态变量，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果动态生成类（将类信息放入永久代）或大量地执行 String.intern （将字段串放入永久代中的常量区），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能（发生 GC 会发生 Stop The Word,造成性能受到一定影响，后文会提到），也就不存在由于永久代限制大小而导致的 OOM 异常了（假设总内存1G，JVM 被分配内存 100M， 理论上元空间可以分配 2G-100M = 1.9G，空间大小足够），也方便在元空间中统一管理。综上所述，在 Java 8 以后这一区域也不需要进行 GC

> 堆外内存不受 GC控制，无法通过 GC 释放内存

- 堆

前面几块数据区域都不进行 GC，那只剩下堆了，是的，这里是 GC 发生的区域！对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收，这块也是我们之后重点需要分析的区域

## 元空间(Metaspace)

> 到了 JDK8，彻底废弃了永久代(PermGen)，Metaspace 取而代之。

### 一、什么是 Metaspace
Metaspace 区域位于堆外，所以它的最大内存大小取决于系统内存，而不是堆大小，我们可以指定 MaxMetaspaceSize 参数来限定它的最大内存。

Metaspace 是用来存放 class metadata 的，class metadata 用于记录一个 Java 类在 JVM 中的信息，包括但不限于 JVM class file format 的运行时数据： 

1. Klass 结构，这个非常重要，把它理解为一个 Java 类在虚拟机内部的表示吧；
2. method metadata，包括方法的字节码、局部变量表、异常表、参数信息等；
3. 常量池；
4. 注解；
5. 方法计数器，记录方法被执行的次数，用来辅助 JIT 决策；

### 二、什么时候分配 Metaspace 空间

当一个类被加载时，它的类加载器会负责在 Metaspace 中分配空间用于存放这个类的元数据。

### 三、什么时候回收 Metaspace 空间
分配给一个类的空间，是归属于这个类的类加载器的，只有当这个类加载器卸载的时候，这个空间才会被释放。

所以，只有当这个类加载器加载的所有类都没有存活的对象，并且没有到达这些类和类加载器的引用时，相应的 Metaspace 空间才会被 GC 释放。

## 虚拟机栈

> 栈是运行时的单位， 而堆是存储的单位

- 只有入栈和出栈， 不存在垃圾回收， 生命周期和线程一样
- 可能出现的异常： 
  - StackOverflowError： 分配固定的栈内存， 如果还要分配则抛出
  - OOM： 分配的时候内存不够了
- 栈的存储单位： 栈的数据都是以 `栈帧` 的格式存在， 每个方法对应一个栈帧

### 一、栈帧的内部结构

- **局部变量表**
  - 定义为一个数组， 基本存储单位是 Slot(变量槽) 主要存储方法参数和方法内的局部变量。 
  - 大小在编译阶段就确定了。 变量只在当前方法有效， 方法结束后，随着方法栈帧的销毁，局部变量表也销毁
  - 如果是构造器方法或者实例方法， 数组的第 0 位是 this。 所以静态方法里不可以使用 this
  - 局部变量表中的变量也是垃圾回收的根节点之一， 被局部变量表中直接或间接引用的对象都不会回收
- **操作数栈(表达式栈)**
  - 方法执行过程中， 根据字节码指令， 往栈中写入或提取。 主要用于保存计算过程的中间结果， 同时作为计算过程中变量临时的存储空间。
  - 某些操作如： 交换、求和， 将操作数全部取出再将结果压入栈
  - 如果被调用的方法带有返回值， 其返回值将会被压入当前操作数栈。
  - > Java 虚拟机的`解释引擎是基于栈的执行引擎`， 这里的栈就是操作数栈
- 动态链接 或者 指向运行时常量池的方法引用
  - 每个栈帧内部都包含一个指向 `运行时常量池` 中该栈帧所属方法的引用。 其目的就是支持当前方法能够实现 `动态链接`
  - Java 源文件被编译到字节码文件时， 所有的变量和方法引用都作为符号引用保存在 Class 文件的常量池中。 `动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。`
- 方法返回地址 或者 方法正常退出或者异常退出的地址
  - 存放调用该方法的 pc 寄存器的值
  - 即调用该方法的指令的下一条指令的地址。 而异常退出的， 返回地址是要通过异常表来确定
- 附加信息： 可有可无， 一般可能是 debug 的信息

### 补充

#### 静态链接 & 动态链接
- 静态链接
如果被调用的**目标方法在编译期可知**， 且运行时保持不变。 这种情况下将调用方法的符号引用转化为直接引用的过程称之为静态链接。
- 动态链接
如果被调用的**目标方法在编译期无法被确定下来**

#### 早期绑定 & 晚期绑定
对应上面的 静态链接 & 动态链接

> 绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程

- 早期绑定
指被调用的方法在编译期可知， 即静态链接的方式将调用方法的符号引用转化为直接引用
- 晚期绑定
与上面相反
#### 非虚方法
- 编译期间就确定具体的调用， 且在运行时不可变。这样的方法叫非虚方法。
- 静态、私有、final、实例构造器、父类方法都是非虚方法
- 其他方法为虚方法  能重写的为虚方法。 为了提高找到虚方法的位置， 类加载的解析阶段会生成虚方法表。


#### 动态类型语言和静态类型语言两者的区别
> Java 属于静态语言  但是一定程度支持动态类型

就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。

说的再直白一点就是，**静态类型语言是判断变量自身的类型信息;动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息,**这是动态语言的一-个重要特征。

## 堆

### 一、核心概述

- 一个JVM实例只存在-一个堆内存，堆也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。
	- 堆内存的大小是可以调节的。
- 《Java虚拟机规范》规定，堆可以处于**物理上不连续**的内存空间中，但在**逻辑上它应该被视为连续的**。
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer，TLAB) 。

#### 内存细分

Java7 及以前逻辑上分为三部分： 新生区 + 养老区 + 永久区
Java8 及以后逻辑上分为三部分： 新生区 + 养老区 + 元空间

> 这些叫法一样 新生区-新生代-年轻代 养老区-老年区-老年代  永久区-永久代

### 堆空间的查看

1. 设置堆空间大小的参数
	- -X 是jvm的运行参数
	- -Xms 用来设置堆空间(年轻代+老年代)的初始内存大小 ms 是memory start
	- -Xmx 用来设置堆空间(年轻代+老年代)的最大内存大小
2. 默认堆空间的大小.
	初始内存大小: 物理电脑内存大小 / 64
	最大内存大小: 物理电脑内存大小 / 4

3. 手动设置: - Xms600m - Xmx600m
	- 开发中建议将初始堆内存和最大的堆内存设置成相同的值。 **(避免重复的回收及分配内存， 与常量池设置初始和最大一样的原因一致)**
4. 查看设置的参数:
   1. jps / jstat -gc 进程id
   2. - XX: +PrintGCDetails(放在 idea 启动配置的 VM options)
